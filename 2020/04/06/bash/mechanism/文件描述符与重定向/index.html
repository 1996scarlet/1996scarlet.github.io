<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>bash/mechanism/文件描述符与重定向 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="文件描述符Linux 操作系统中的文件 I&#x2F;O 由内核通过文件描述符来完成. 当前进程所追踪的文件描述符以符号链接的形式存放在 &#x2F;proc&#x2F;self&#x2F;fd&#x2F; 路径下, 其中最特殊的是编号为 0 1 2 的文件描述符, 分别代表 stdin , stdout , stderr . 此外, shell 还可以将 TCP 或 UDP 端口作为文件描述符来对待. 123456789101112&gt; l">
<meta property="og:type" content="article">
<meta property="og:title" content="bash&#x2F;mechanism&#x2F;文件描述符与重定向">
<meta property="og:url" content="http://yoursite.com/2020/04/06/bash/mechanism/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="文件描述符Linux 操作系统中的文件 I&#x2F;O 由内核通过文件描述符来完成. 当前进程所追踪的文件描述符以符号链接的形式存放在 &#x2F;proc&#x2F;self&#x2F;fd&#x2F; 路径下, 其中最特殊的是编号为 0 1 2 的文件描述符, 分别代表 stdin , stdout , stderr . 此外, shell 还可以将 TCP 或 UDP 端口作为文件描述符来对待. 123456789101112&gt; l">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-06T13:38:57.641Z">
<meta property="article:modified_time" content="2020-04-04T09:59:17.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-bash/mechanism/文件描述符与重定向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      bash/mechanism/文件描述符与重定向
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p><code>Linux</code> 操作系统中的文件 <code>I/O</code> 由内核通过文件描述符来完成. 当前进程所追踪的文件描述符以符号链接的形式存放在 <code>/proc/self/fd/</code> 路径下, 其中最特殊的是编号为 <code>0 1 2</code> 的文件描述符, 分别代表 <code>stdin</code> , <code>stdout</code> , <code>stderr</code> . 此外, <code>shell</code> 还可以将 <code>TCP</code> 或 <code>UDP</code> 端口作为文件描述符来对待.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l /dev/std*</span><br><span class="line">lrwxrwxrwx 1 root root 15 Mar 12 18:02 /dev/stderr -&gt; /proc/self/fd/2</span><br><span class="line">lrwxrwxrwx 1 root root 15 Mar 12 18:02 /dev/stdin -&gt; /proc/self/fd/0</span><br><span class="line">lrwxrwxrwx 1 root root 15 Mar 12 18:02 /dev/stdout -&gt; /proc/self/fd/1</span><br><span class="line"></span><br><span class="line">&gt; ls -gGl /proc/self/fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 0 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 2 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 20 -&gt; <span class="string">'socket:[42311]'</span></span><br><span class="line">lr-x------ 1 64 Mar 12 21:46 3 -&gt; /proc/29324/fd</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 对每个进程来说 <code>/proc/self/</code> 下的文件都是独立存在的, 该路径实际上是个符号链接, 指向 <code>/proc/&lt;pid&gt;/</code> . 而从操作系统层面来看, <code>proc</code> 其实是一种特殊的文件系统, 用于给程序提供内核态数据结构的接口, 这个虚拟文件系统默认被挂载在 <code>/proc</code> 路径下, 通过 <code>mount -t</code> 可以将其挂载到其他地方:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount -t &lt;types&gt; &lt;source&gt; &lt;target&gt;</span></span><br><span class="line">&gt; mount -t proc proc /proc</span><br></pre></td></tr></table></figure>

<p>对于 <code>pipe</code> 和 <code>socket</code> , 文件描述符符号链接中会存储文件的类型和 <code>inode</code> , 例如上述例子中的 <code>20 -&gt; &#39;socket:[42311]&#39;</code> , 这说明 <code>20</code> 号文件描述符指向了一个 <code>inode=42311</code> 且已经被删除的 <code>socket</code> . 而对于通过 <code>epoll_create</code> , <code>signalfd</code> , <code>eventfd</code> 等特殊系统调用建立的文件描述符, 其符号链接中会存储 <code>anon_inode:&lt;file-type&gt;</code> 结构的信息, 以 <code>epoll</code> 为例, 其文件描述符中的内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anon_inode:[eventpoll]</span><br></pre></td></tr></table></figure>

<p>对于通过计划任务如: <code>at</code> , <code>cron</code> 等执行的命令, 由于其不像普通命令一样能够继承父 <code>shell</code> 传递来的文件描述符, 因此这类命令的文件描述符一般指向管道或临时文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; at 1140</span><br><span class="line">warning: commands will be executed using /bin/sh</span><br><span class="line">at&gt; ls -l /proc/self/fd/ &gt; /tmp/test.at</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 6 at Fri Mar 13 11:40:00 2020</span><br><span class="line">&gt; cat /tmp/test.at </span><br><span class="line">total 0</span><br><span class="line">lr-x------ 1 remilia remilia 64 Mar 13 11:40 0 -&gt; /var/spool/cron/atjobs/a000060192d99c (deleted)</span><br><span class="line">l-wx------ 1 remilia remilia 64 Mar 13 11:40 1 -&gt; /tmp/test.at</span><br><span class="line">lrwx------ 1 remilia remilia 64 Mar 13 11:40 2 -&gt; /var/spool/cron/atspool/a000060192d99c</span><br><span class="line">lr-x------ 1 remilia remilia 64 Mar 13 11:40 3 -&gt; /proc/19462/fd</span><br></pre></td></tr></table></figure>

<h2 id="重定向执行顺序"><a href="#重定向执行顺序" class="headerlink" title="重定向执行顺序"></a>重定向执行顺序</h2><p>在 <code>shell</code> 中, 我们经常会使用管道与重定向用于控制命令或脚本的输入输出, 这些操作的本质就是更改文件描述符符号链接所指向的文件. 在 <code>shell</code> 中执行一个命令之前会按照如下步骤进行文件描述符操作:</p>
<ul>
<li>如果上一个命令的输出通过管道 <code>|</code> 与当前命令的输入相连, 则把 <code>/proc/&lt;current_process_ID&gt;/fd/0</code> 的指向更新到与 <code>/proc/&lt;previous_process_ID/fd/1</code> 相同指向的匿名管道.</li>
<li>如果当前命令的输出通过管道 <code>|</code> 连接到下一个命令的输入, 则将 <code>/proc/&lt;current_process_ID&gt;/fd/1</code> 的指向更新到另一个匿名管道中.</li>
<li>从左向右按顺序解析所有的重定向符号.<ul>
<li>如果<strong>命令后接</strong>有 <code>N&gt;&amp;M</code> 或 <code>N&lt;&amp;M</code> 则将 <code>/proc/self/fd/N</code> 的输出或输入符号链接指向 <code>/proc/self/fd/M</code> 符号链接指向的目标.</li>
<li>如果有 <code>N &gt; file</code> 或 <code>N &lt; file</code> 则将 <code>/proc/self/fd/N</code> 的输出或输入符号链接指向 <code>file</code> .</li>
<li>如果出现 <code>N&gt;&amp;-</code> 则删除 <code>/proc/self/fd/N</code> 符号链接.</li>
</ul>
</li>
<li>执行命令.</li>
</ul>
<h2 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h2><p><code>shell</code> 中支持的重定向符号如下表所示:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; file</td>
<td>将命令的输入进行重定向到文件</td>
</tr>
<tr>
<td>&gt; file 或 1 &gt; file</td>
<td>将命令的输出重定向到文件, 写入方式为覆盖</td>
</tr>
<tr>
<td>&gt;&gt; file 或 1 &gt;&gt; file</td>
<td>将命令的输出重定向到文件, 写入方式为追加</td>
</tr>
<tr>
<td>2 &gt; file</td>
<td>将命令的标准错误重定向到文件 (覆盖)</td>
</tr>
<tr>
<td>2 &gt;&gt; file</td>
<td>将命令的标准错误重定向到文件 (追加)</td>
</tr>
<tr>
<td>&amp;&gt; file 或 &gt;file 2&gt;&amp;1</td>
<td>将命令的标准输出和标准错误都重定向到一个文件中 (覆盖)</td>
</tr>
<tr>
<td>&amp;&gt;&gt; file 或 &gt;&gt;file 2&gt;&amp;1</td>
<td>将命令的标准输出和标准错误都重定向到一个文件中 (追加)</td>
</tr>
<tr>
<td>&lt;&lt; tag 和 &lt;&lt;- tag</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p><code>/dev/null</code> 是一个特殊的文件, 他会丢弃所有传给他的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; &#x2F;dev&#x2F;null</span><br><span class="line">stderr  # 标准输出被丢弃</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) 2&gt; &#x2F;dev&#x2F;null</span><br><span class="line">stdout  # 标准错误被丢弃</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line"># 标准输出和标准错误都被丢弃</span><br></pre></td></tr></table></figure>

<p>在分析带有重定向的命令时, 要时刻牢记重定向永远是相对命令产生的概念, 因此重定向的结果只与出现的顺序有关:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; c &gt; d echo &quot;abcd&quot; &gt; e</span><br><span class="line"># 从左到右解析重定向符号</span><br><span class="line"># 先把 echo 的 FD1 更新为指向 c</span><br><span class="line"># 再把 echo 的 FD1 更新为指向 d</span><br><span class="line"># 最后把 echo 的 FD1 更新为指向 e</span><br><span class="line">&gt; cat e</span><br><span class="line">abcd</span><br><span class="line">&gt; cat c d</span><br><span class="line"># 没有输出 因为上个命令的输出没有最终指向它们</span><br><span class="line"></span><br><span class="line">&gt; &lt; e grep . &lt; d</span><br><span class="line"># 没有输出因为 d 为空</span><br><span class="line">&gt; &lt; d grep . &lt; e</span><br><span class="line">abcd  # 有输出因为最终是把 grep 的 FD0 更新为指向 e</span><br></pre></td></tr></table></figure>

<p> 再次强调, 重定向符号的顺序会影响最终重定向的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 只重定向标准输出</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log1</span><br><span class="line">stderr</span><br><span class="line">&gt; cat log1</span><br><span class="line">stdout</span><br><span class="line"></span><br><span class="line"># 重定向标准输出和标准错误到同一文件</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &amp;&gt; log2</span><br><span class="line"># 等价于 ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 2&gt;&amp;1</span><br><span class="line"># 等价于 ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 2&gt;&gt;log2</span><br><span class="line">&gt; cat log2</span><br><span class="line">stdout</span><br><span class="line">stderr</span><br><span class="line"></span><br><span class="line"># 错误写法</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 2&gt;log2</span><br><span class="line">&gt; cat log2</span><br><span class="line">stderr  # 标准错误把标准输出给覆盖了</span><br><span class="line"></span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) 2&gt;log2 1&gt;&gt;log2</span><br><span class="line">&gt; cat log2</span><br><span class="line">stderr  # 因为标准输出的写入顺序要优先于标准错误</span><br><span class="line"></span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 1&gt;&amp;2</span><br><span class="line">stdout  # 先把 FD1 指向 log2, 再把 FD1 指向标准错误</span><br><span class="line">stderr</span><br><span class="line">&gt; cat log2  # 因此 log2 里什么也没有</span><br></pre></td></tr></table></figure>

<h2 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号"></a>管道符号</h2><p>管道是进程间通讯的经典方法, 在 <code>shell</code> 中, 我们使用匿名管道符号 <code>|</code> 将前一个进程的 <code>stdout</code> 与后一个进程的 <code>stdin</code> 连接. 如下例, 我们先用 <code>cat</code> 将文件合并, 然后将其传递给后续命令进行处理, 这样就构建了处理流水线:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat $filename1 $filename2 | grep $search_word</span><br><span class="line">&gt; cat f&#123;1,2,3,2,3,1,1&#125; | sort -r | uniq  </span><br><span class="line">3  </span><br><span class="line">2  </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>shell</code> 中支持的管道符号如下表所示:<br>| 符号 | 说明 |<br>| – | – |<br>| cmd1 | cmd2  | 将 <code>cmd1</code> 的标准输出和 <code>cmd2</code> 的标准输入指向 <code>pipe</code> |<br>| cmd1 |&amp; cmd2  | 现将 <code>cmd1</code> 的标准输出和 <code>cmd2</code> 的标准输入指向 <code>pipe</code> , 再将 <code>cmd1</code> 的标准错误指向到当前标准输出的指向, 等价于 <code>cmd1 2&gt;&amp;1 | cmd2</code> .|</p>
<p>管道默认是将左侧的标准输出和右侧的标准输入连接到同一个 <code>pipe</code> 文件上, 如果我们想把标准错误也传递给右侧可以按照如下方式操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 传递 stdin 与 stderr</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) |&amp; awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line"># 等价于( echo stdout; echo stderr &gt;&amp;2 ) 2&gt;&amp;1 | awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line">From pipe: stdout</span><br><span class="line">From pipe: stderr</span><br><span class="line"></span><br><span class="line"># 只传递 stderr</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null | awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line">From pipe: stderr</span><br><span class="line"></span><br><span class="line">1. 首先处理管道, 将&quot;command FD 1&quot; 和 &quot;grep FD 0&quot;都指向管道</span><br><span class="line">2. 将&quot;command FD2&quot;指向&quot;command FD1&quot;当前的指向 (也就是管道)</span><br><span class="line">3. 将&quot;command FD1&quot;指向 &#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line"># 错误写法</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 | awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line"></span><br><span class="line">1.  首先处理管道, 将&quot;command FD 1&quot; 和 &quot;grep FD 0&quot;都指向管道</span><br><span class="line">2.  将&quot;command FD 1&quot;指向 &#x2F;dev&#x2F;null</span><br><span class="line">3.  将&quot;command FD 2&quot;指向&quot;command FD 1&quot;当前的指向 (&#x2F;dev&#x2F;null)</span><br><span class="line">4. 管道都没有输入端, 自然不会传递任何数据给 grep</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[warning]注意: 要注意区分管道符号与重定向符号. <code>|</code> 左边的命令应该有标准输出, 其右边的命令应该接受标准输入; 但重定向符号的右侧只能是文件. 此外, 管道触发两个 <code>sub shell</code> 执行 <code>|</code> 两边的程序；而重定向是在一个进程内执行.</p>
</blockquote>
<p>由于管道两侧的命令会放到 <code>sub shell</code> 中执行, 因此不能改变父 <code>shell</code> 中的变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; var&#x3D;&quot;init_value&quot;</span><br><span class="line">&gt; echo &quot;new_value&quot; | read var</span><br><span class="line">&gt; echo &quot;var &#x3D; $var&quot;</span><br><span class="line">var &#x3D; init_value</span><br></pre></td></tr></table></figure>

<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>使用 <code>|</code> 建立的管道是匿名管道, 只在父进程与子进程之间起作用. 如果我们需要复杂的进程通信(如: 跨终端通信), 需要使用 <code>mkfifo</code> 创建命名管道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkfifo &#x2F;tmp&#x2F;fifo1</span><br><span class="line"># mknod &#x2F;tmp&#x2F;fifo1 p</span><br><span class="line">&gt; file &#x2F;tmp&#x2F;fifo1</span><br><span class="line">&#x2F;tmp&#x2F;fifo1: fifo (named pipe)</span><br><span class="line">&gt; ls -lF &#x2F;tmp&#x2F;fifo1  # -F 选项会在结尾加管道符号</span><br><span class="line">prw-rw-r-- 1 remilia remilia 0 Mar 15 19:18 &#x2F;tmp&#x2F;fifo1|</span><br></pre></td></tr></table></figure>

<p>管道的读写遵照先进先出原则, 其内容驻留在内存中而不是被写到硬盘上, 数据内容只有在输入输出端都打开时才会传送. <code>FIFO</code> 具有以下特点:</p>
<ol>
<li>当写进程向管道中写数据的时候，如果没有进程读取这些数据，写进程会堵塞</li>
<li>当读取管道中的数据的时候，如果没有数据，读取进程会被堵塞</li>
<li>当写进程堵塞的时候，有读进程读取数据，那么写进程恢复正常</li>
<li>当读进程堵塞的时候，如果写进程写了数据，那么读进程会读取数据，然后正常执行后面的代码</li>
</ol>
<p>下面是一个循环读取 <code>FIFO</code> 内容的脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">pipe&#x3D;&#x2F;tmp&#x2F;fifo1</span><br><span class="line"></span><br><span class="line">trap &quot;rm -f $pipe&quot; EXIT</span><br><span class="line"></span><br><span class="line">if [[ ! -p $pipe ]]; then</span><br><span class="line">    mkfifo $pipe</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 不加外面这层则读到 end-of-stream 就退出</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    while read line</span><br><span class="line">    do</span><br><span class="line">        if [[ &quot;$line&quot; &#x3D;&#x3D; &#39;quit&#39; ]]; then</span><br><span class="line">            break</span><br><span class="line">        else</span><br><span class="line">            echo $line</span><br><span class="line">        fi</span><br><span class="line">    done &lt; $pipe</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Stop reader....&quot;</span><br></pre></td></tr></table></figure>

<h2 id="自定义文件描述符"><a href="#自定义文件描述符" class="headerlink" title="自定义文件描述符"></a>自定义文件描述符</h2><p>我们可以通过 <code>exec</code> 命令自定义文件描述符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># exec fdN&gt; file</span><br><span class="line">&gt; exec 6&gt; file  # 把文件描述符 6 分配给 file 只写</span><br><span class="line">&gt; echo &quot;line1&quot; &gt;&amp; 4</span><br><span class="line">&gt; cat file</span><br><span class="line">line1</span><br><span class="line"></span><br><span class="line"># exec fdN&lt; file</span><br><span class="line">&gt; exec 7&lt; file # 把文件描述符 7 分配给 file 只读</span><br><span class="line">&gt; echo &quot;line2&quot; &gt; file</span><br><span class="line">&gt; cat &lt;&amp; 7</span><br><span class="line">line2</span><br><span class="line"></span><br><span class="line"># exec fdN&lt;&gt; file</span><br><span class="line">&gt; exec 8&lt;&gt; file # 读写 多用于fifo</span><br><span class="line"></span><br><span class="line"># read -u 表示从文件描述符读取</span><br><span class="line">&gt; read -u 7 line; echo $line</span><br><span class="line">line2</span><br></pre></td></tr></table></figure>

<p>我们可以在脚本中将标准输入描述符暂存, 从而实现让脚本能够自由切换输入为文件或终端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CONFIG&#x3D;&#x2F;var&#x2F;tmp&#x2F;sysconfig.out</span><br><span class="line"></span><br><span class="line"># 暂存标准输入描述符</span><br><span class="line">exec 7&lt;&amp;0</span><br><span class="line"></span><br><span class="line"># 切换输入为文件</span><br><span class="line">exec &lt; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">read rootpasswd</span><br><span class="line">echo $rootpasswd &gt;&gt; &quot;$CONFIG&quot;</span><br><span class="line"></span><br><span class="line"># 恢复标准输入 并删除暂存描述符</span><br><span class="line">exec 0&lt;&amp;7 7&lt;&amp;-</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>exec fd&lt;&amp;-</code> 关闭一个文件描述符, 例如我们可以将标准输出打印到屏幕的同时将标准错误传递到管道右侧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat listdirs.sh</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">INPUTDIR&#x3D;&quot;$1&quot;</span><br><span class="line"></span><br><span class="line"># 文件描述符 6 指向标准输出</span><br><span class="line">exec 6&gt;&amp;1</span><br><span class="line"></span><br><span class="line"># ls 的 FD1 和 awk 的 FD0 都指向管道</span><br><span class="line"># 把 ls 的 FD2 指向 FD1 当前的指向, 也就是管道</span><br><span class="line"># 把 ls 的 FD1 指向 FD6 当前的指向, 也就是标准输出</span><br><span class="line"># 管道两侧的 subshell 会继承父 shell 的文件描述符</span><br><span class="line"># 关闭 ls 的 FD6</span><br><span class="line"># 关闭 awk 的 FD6</span><br><span class="line">ls &quot;$INPUTDIR&quot;&#x2F;* 2&gt;&amp;1 &gt;&amp;6 6&gt;&amp;- | awk -F&quot;:&quot; &#39;&#123;print &quot;ERROR: &quot; $2&#125;&#39; 6&gt;&amp;-</span><br><span class="line"></span><br><span class="line"># 关闭当前 shell 的文件描述符</span><br><span class="line">exec 6&gt;&amp;-</span><br><span class="line"></span><br><span class="line">&gt; bash listdirs.sh &#x2F;root</span><br><span class="line">ERROR:  cannot access &#39;&#x2F;root&#x2F;*&#39;</span><br></pre></td></tr></table></figure>

<p>如果在文件描述符未被释放的情况下删除原文件, 可以通过拷贝描述符的方式恢复文件数据(拷贝后的文件与原文件 <code>inode</code> 不同):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; touch file1</span><br><span class="line">&gt; exec 6&gt; file1</span><br><span class="line">&gt; ll &#x2F;proc&#x2F;$&#x2F;fd&#x2F;6</span><br><span class="line">lrwx------ 1 remilia remilia 64 Mar 15 18:58 6 -&gt; &#x2F;home&#x2F;remilia&#x2F;file1</span><br><span class="line">&gt; echo &quot;abcd&quot; &gt;&amp; 6</span><br><span class="line">&gt; cat file1</span><br><span class="line">abcd</span><br><span class="line">&gt; cat &#x2F;proc&#x2F;$&#x2F;fd&#x2F;6</span><br><span class="line">abcd</span><br><span class="line">&gt; rm file1</span><br><span class="line">&gt; lrwx------ 1 remilia remilia 64 Mar 15 18:58 6 -&gt; &#39;&#x2F;home&#x2F;remilia&#x2F;file1 (deleted)&#39;</span><br><span class="line">&gt; cp &#x2F;proc&#x2F;$&#x2F;fd&#x2F;6 ~&#x2F;file1</span><br><span class="line">&gt; cat file1</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>

<h2 id="嵌入文档"><a href="#嵌入文档" class="headerlink" title="嵌入文档"></a>嵌入文档</h2><p>嵌入文档 (Here Document) 是一种特殊的重定向方式，它的基本的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br><span class="line"></span><br><span class="line"># 加个 - 也可以</span><br><span class="line">command &lt;&lt;- delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>

<p>它的作用是将两个 <code>delimiter</code> 之间的内容 <code>document</code> 作为输入传递给 <code>command</code> . 注意：</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。</li>
</ul>
<p>下面的例子，通过 <code>wc -l</code> 命令计算 <code>document</code> 的行数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; wc -l &lt;&lt; EOF</span><br><span class="line">&gt; This is a simple lookup program</span><br><span class="line">&gt; for good (and bad) restaurants</span><br><span class="line">&gt; in Cape Town.</span><br><span class="line">&gt; EOF</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>也可以 将 Here Document 用在脚本中，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">wc -w &lt;&lt;EOF</span><br><span class="line">This is a test.</span><br><span class="line">Apple juice.</span><br><span class="line">100% fruit juice and no added sugar, colour or preservative.</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" data-id="ck8oiuufp0009e6ax8y1hdnw4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/06/bash/mechanism/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          bash/mechanism/退出状态
        
      </div>
    </a>
  
  
    <a href="/2020/04/06/bash/%E8%AE%A4%E8%AF%86Bash/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">bash/认识Bash</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">bash/mechanism/信号处理</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A7%8D%E7%B1%BB/">bash/mechanism/命令的种类</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/">bash/mechanism/命令的执行方式</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/">bash/mechanism/自动补全</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%AD%90shell/">bash/mechanism/子shell</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>