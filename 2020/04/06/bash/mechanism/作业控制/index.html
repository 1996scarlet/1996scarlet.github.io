<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>bash/mechanism/作业控制 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="作业控制在 shell 中通过 command &amp; 可以创建后台作业, 通过 jobs -l 命令可以查看当前 shell 中维护的作业列表, 包括他们的作业号, 进程号, 运行状态. 其中作业号( jobID 或 JOB_SPEC )是作业在当前 shell 中的唯一标识. 作业与进程作业相比于进程是更高级的调度单位, 其定位类似于进程组, 但与进程组不同的是, 作业只维护其初始进程,">
<meta property="og:type" content="article">
<meta property="og:title" content="bash&#x2F;mechanism&#x2F;作业控制">
<meta property="og:url" content="http://yoursite.com/2020/04/06/bash/mechanism/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="作业控制在 shell 中通过 command &amp; 可以创建后台作业, 通过 jobs -l 命令可以查看当前 shell 中维护的作业列表, 包括他们的作业号, 进程号, 运行状态. 其中作业号( jobID 或 JOB_SPEC )是作业在当前 shell 中的唯一标识. 作业与进程作业相比于进程是更高级的调度单位, 其定位类似于进程组, 但与进程组不同的是, 作业只维护其初始进程,">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-06T13:38:57.641Z">
<meta property="article:modified_time" content="2020-04-04T03:31:05.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-bash/mechanism/作业控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      bash/mechanism/作业控制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h1><p>在 <code>shell</code> 中通过 <code>command &amp;</code> 可以创建后台作业, 通过 <code>jobs -l</code> 命令可以查看当前 <code>shell</code> 中维护的作业列表, 包括他们的作业号, 进程号, 运行状态. 其中作业号( <code>jobID</code> 或 <code>JOB_SPEC</code> )是作业在当前 <code>shell</code> 中的唯一标识.</p>
<h2 id="作业与进程"><a href="#作业与进程" class="headerlink" title="作业与进程"></a>作业与进程</h2><p>作业相比于进程是更高级的调度单位, 其定位类似于进程组, 但与进程组不同的是, 作业只维护其初始进程, 一旦所有的初始进程退出则代表作业执行完毕, 未结束的子进程不会被作业追踪, 如下例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">(sleep 20 &amp; sleep 2) &amp;</span><br><span class="line"><span class="built_in">jobs</span> -l</span><br><span class="line">pstree -apg $</span><br><span class="line">ps -ejfH | awk <span class="string">'$10 ~ /^sleep/ &#123;printf "%s %s -- PPID:%s, PGID:%s\n",$10,$11,$3,$4&#125;'</span></span><br><span class="line">sleep 2</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">jobs</span> -l</span><br><span class="line">pstree -apg $</span><br><span class="line">ps -ejfH | awk <span class="string">'$10 ~ /^sleep/ &#123;printf "%s %s -- PPID:%s, PGID:%s\n",$10,$11,$3,$4&#125;'</span></span><br><span class="line">pkill sleep</span><br></pre></td></tr></table></figure>

<p>运行这个例子可以得到如下输出, 可以看到整个作业初始只包括一个没有 <code>wait</code> 的 <code>bash</code> 进程 <code>19318</code> , 运行 <code>2</code> 秒后 <code>19321</code> 退出导致 <code>19318</code> 退出, 因此作业结束, 此时 <code>19319</code> 由于父进程退出而变为孤儿进程, 但其<strong>进程组</strong>号未改变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[1]+ 19318 Running                 ( sleep 20 &amp; sleep 2 ) &amp;</span><br><span class="line">bash,19317,19317 pgroup.sh</span><br><span class="line">  ├─bash,19318,19317 pgroup.sh  # 作业的初始进程</span><br><span class="line">  │   ├─sleep,19319,19317 20  # 作业运行中创建的子进程</span><br><span class="line">  │   └─sleep,19321,19317 2  # 作业运行中创建的子进程</span><br><span class="line">  └─pstree,19320,19317 -apg 19317</span><br><span class="line">sleep 20 -- PPID:19318, PGID:19317</span><br><span class="line">sleep 2 -- PPID:19318, PGID:19317</span><br><span class="line"></span><br><span class="line"># 进程 19321 退出 由于没有 wait 导致整个作业退出</span><br><span class="line">[1]+ 19318 Done                    ( sleep 20 &amp; sleep 2 )</span><br><span class="line">bash,19317,19317 pgroup.sh</span><br><span class="line">  └─pstree,19328,19317 -apg 19317</span><br><span class="line">sleep 20 -- PPID:1, PGID:19317  # 变为孤儿进程 但进程组号未变</span><br></pre></td></tr></table></figure>

<p>作业的存在是为了方便 <code>shell</code> 对前后台进程(进程组)进行管理, 一个 <code>shell</code> 进程在同一时刻只能存在一个前台作业但可以存在多个后台作业. 每个作业可以包含一个或多个进程, 具体体现为如下情况:</p>
<ul>
<li>作业中包含单个进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 50 &amp;</span><br><span class="line">[1] 20536  <span class="comment"># 作业号为 1, 包含的进程号为 20536</span></span><br><span class="line">&gt; <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 20536 Running                 sleep 50 &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>作业中包含进程及其子进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; (sleep 20 &amp; sleep 10 &amp; <span class="built_in">wait</span>) &amp;</span><br><span class="line">[1] 21111</span><br><span class="line">&gt; pstree -ap $</span><br><span class="line">bash,21023</span><br><span class="line">  ├─bash,21111  <span class="comment"># 作业的初始进程</span></span><br><span class="line">  │   ├─sleep,21112 20</span><br><span class="line">  │   └─sleep,21113 10</span><br><span class="line">  └─pstree,21116 -ap 21023</span><br></pre></td></tr></table></figure>

<ul>
<li>作业中包含多个进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 10 | sleep 8 &amp;  <span class="comment"># 管道两侧在 sub shell 中运行</span></span><br><span class="line">[1] 20689</span><br><span class="line">&gt; <span class="built_in">jobs</span> -l  <span class="comment"># 作业中包含两个初始进程</span></span><br><span class="line">[1]+ 20688 Running                 sleep 10</span><br><span class="line">     20689                       | sleep 8 &amp;</span><br></pre></td></tr></table></figure>

<h2 id="前台作业管理"><a href="#前台作业管理" class="headerlink" title="前台作业管理"></a>前台作业管理</h2><p>在一个 <code>shell</code> 会话中直接输入命令执行的作业会在前台运行, 前台作业会一直阻塞 <code>shell</code> 直到其执行完毕或被挂起. 前台作业能够优先处理传递给进程组的信号, 并且优先占用输入文件描述符. 以外部命令 <code>cat</code> 命令为例, 在启动后, <code>shell</code> 会把当前的前台进程组指定为新建立的 <code>cat</code> 进程组, 这样 <code>cat</code> 就接管了整个 <code>shell</code> 的标准输入, 标准输出和标准错误文件描述符. 命令的组合也可以作为前台任务被执行, 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"Hello World"</span>; sleep 10; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>要退出上面这个死循环需要给进程发送中断信号, 为了方便, 我们一般使用 <code>Ctrl + C</code> 直接给整个进程组发送 <code>SIGINT</code> 信号. 但如果我们要在不退出前台作业的基础上拿回终端控制权, 就需要给作业发送 <code>SIGTSTP</code> 或 <code>SIGSTOP</code> 信号来让他暂时挂起.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ping 127..0.0.1</span><br><span class="line">^Z  <span class="comment"># 按下 Ctrl + Z</span></span><br><span class="line">[1]+  Stopped                 ping 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>通过 <code>Ctrl + Z</code> 可以给 <code>shell</code> 中的前台作业发送 <code>SIGTSTP</code> , 这样 <code>ping</code> 命令就暂时停止了, 我们重新拿回了 <code>shell</code> 的控制权, 通过 <code>ps T</code> 命令可以查看当前 <code>shell</code> 终端关联的所有进程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps T</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 4731 pts/1    Ss     0:00 /bin/bash</span><br><span class="line"> 4738 pts/1    T      0:00 ping 127.0.0.1</span><br><span class="line"> 4891 pts/1    R+     0:00 ps T</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>ping</code> 命令并没有退出, 而且他的状态被改成了 <code>T</code> , 通过查阅 <code>man ps</code> 可以知道, <code>T</code> 状态代表进程被作业控制信号停止. 此外, 可以使用内置命令 <code>suspend</code> 挂起当前 <code>shell</code> .</p>
<h2 id="后台作业管理"><a href="#后台作业管理" class="headerlink" title="后台作业管理"></a>后台作业管理</h2><p>除了让前台作业挂起将其变为后台作业之外, 通过 <code>command &amp;</code> 的方式可以让命令直接在后台运行, 我们在刚才挂起的 <code>ping</code> 基础上再添加两个运行中的后台作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; xeyes &amp;</span><br><span class="line">&gt; xload &amp;</span><br></pre></td></tr></table></figure>

<p>通过 <code>jobs -l</code> 可以查看当前 <code>shell</code> 中的后台作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+  6528 Stopped                 ping 127.0.0.1</span><br><span class="line">[2]   7101 Running                 xeyes &amp;</span><br><span class="line">[3]-  7104 Running                 xload &amp;</span><br></pre></td></tr></table></figure>

<p>第一列 <code>[1]</code> 表示作业号 <code>JOB_SPEC</code> , 后面跟随的 <code>+</code> 表示其为当前作业, 或者说最近的被调往前台的作业, 而 <code>-</code> 表示当前作业的前一个作业, 我们可以通过 <code>%JOB_SPEC %+ %-</code> 的方式在命令中访问这些作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">fg</span> %2  <span class="comment"># 或 fg 2, 因为 fg 只对作业有效所以可以省略百分号</span></span><br><span class="line">xeyes</span><br><span class="line">^Z  <span class="comment"># 挂起</span></span><br><span class="line">[2]+  Stopped                 xeyes</span><br><span class="line">&gt; <span class="built_in">jobs</span>  <span class="comment"># 不带 l 选项则不显示进程号</span></span><br><span class="line">[1]-  Stopped                 ping 127.0.0.1  <span class="comment"># 减号表示前一个作业</span></span><br><span class="line">[2]+  Stopped                 xeyes  <span class="comment"># 加号表示当前作业</span></span><br><span class="line">[3]   Running                 xload &amp;</span><br><span class="line">&gt; <span class="built_in">fg</span>  <span class="comment"># 等价于 fg + 或 fg %+ 或 fg %%</span></span><br></pre></td></tr></table></figure>

<p>第二列数字 <code>6528</code> 为该作业包含的初始进程进程号, 初始进程可以为多个, 所有初始进程执行完毕则作业执行完毕. 第三列表示作业的状态, 包括以下几种:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 5 &amp;</span><br><span class="line">&gt; <span class="built_in">kill</span> %+  <span class="comment"># 等价于 kill %2 百分号不可省略</span></span><br><span class="line">&gt; <span class="built_in">jobs</span></span><br><span class="line">[1]+  Stopped                 ping 127.0.0.1  <span class="comment"># 停止</span></span><br><span class="line">[2]   Terminated              xeyes  <span class="comment"># 被终止</span></span><br><span class="line">[3]-  Running                 xload &amp;  <span class="comment"># 运行态</span></span><br><span class="line">[4]   Done                    sleep 5  <span class="comment"># 成功执行完毕并已经退出, 只会显示一次</span></span><br><span class="line">[5]   Hangup                  ping 127.0.0.1 &gt; /dev/null  <span class="comment"># 挂起 无特殊处理则退出</span></span><br></pre></td></tr></table></figure>

<p>最后一列是作业的运行命令文本, 在命令控制任务中可以使用 <code>%s</code> 和 <code>%?s</code> 通过匹配作业文本的方式指定作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">kill</span> -s int %ping  <span class="comment"># 给作业文本以 ping 开头的作业发送 SIGINT</span></span><br><span class="line">&gt; <span class="built_in">fg</span> %?eye  <span class="comment"># 把作业文本包含 eye 的作业提到前台</span></span><br></pre></td></tr></table></figure>

<p>我们还可以使用 <code>bg</code> 命令让挂起的后台作业直接运行, 而不必将其提到前台, 其用法类似于 <code>fg</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 100</span><br><span class="line">^Z  <span class="comment"># 挂起</span></span><br><span class="line">[1]+  Stopped                 sleep 100</span><br><span class="line">&gt; <span class="built_in">bg</span> 1  <span class="comment"># 等价于 bg %1</span></span><br><span class="line">[1]+ sleep 100 &amp;</span><br><span class="line">&gt; <span class="built_in">jobs</span></span><br><span class="line">[1]+  Running                 sleep 100 &amp;</span><br></pre></td></tr></table></figure>

<p>但要注意, 为了防止后台作业与前台作业争抢输入资源, 只要后台作业执行到需要读取输入的代码段, 就会导致该作业被挂起, 这时使用 <code>bg</code> 命令无效.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">read</span> line; <span class="keyword">done</span> &amp;</span><br><span class="line">[1] 20780</span><br><span class="line">&gt; <span class="built_in">bg</span> 1</span><br><span class="line">[1]+ <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> line;</span><br><span class="line"><span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment"># 被输入挂起 仍处于停止状态</span></span><br><span class="line">[1]+  Stopped                 <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> line;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="作业控制命令与符号"><a href="#作业控制命令与符号" class="headerlink" title="作业控制命令与符号"></a>作业控制命令与符号</h2><p>作业控制命令及其用法可以总结为如下表格:<br>| 符号 | 描述 | 例子 |<br>| — | — | — |<br>| &amp; | 把作业放到后台 | <code>command &amp;</code> |<br>| %n | 作业列表中作业号为 <code>n</code> 的作业 | <code>kill %1</code> |<br>| %s | 作业列表中名称以字符串 <code>s</code> 开头的作业| <code>kill %xe</code> |<br>| %?s | 作业列表中名称包括字符串 <code>s</code> 的作业 | <code>jobs %?ping</code> |<br>| %% 或 %+ | 表示当前作业 | <code>kill %%</code>  <code>kill %+</code> |<br>| %- | 表示当前作业的上一个作业 | <code>bg %-</code> |<br>| Ctrl + Z | 挂起或停止作业 | <code>kill -s stop %ping</code> |<br>| jobs -l | 列出所有作业 | <code>jobs -l</code> |<br>| jobs -r | 列出所有正在运行的作业 | <code>jobs -r</code> |<br>| jobs -s | 列出所有被挂起的作业 | <code>jobs -s</code> |<br>| bg | 让作业在后台运行 | <code>bg %%</code> |<br>| fg | 把作业提到前台 | <code>fg %apt-get</code> |</p>
<h1 id="处理-SIGHUP-信号"><a href="#处理-SIGHUP-信号" class="headerlink" title="处理 SIGHUP 信号"></a>处理 SIGHUP 信号</h1><p>无论是前台作业还是后台作业, 他们都呈树状结构依附于 <code>shell</code> 进程, 在 <code>shell</code> 终端退出时如果存在后台作业, 则会提示 <code>There are stopped jobs.</code> , 如果忽略这个提示继续退出, <code>shell</code> 会向所有作业发送 <code>SIGHUP</code> 信号来进行清理. 如果我们需要某些后台进程在终端退出时仍然继续运行, 就需要对 <code>SIGHUP</code> 信号进行处理.</p>
<h2 id="外部命令-nohup"><a href="#外部命令-nohup" class="headerlink" title="外部命令 nohup"></a>外部命令 nohup</h2><p>使用 <code>nohup</code> 命令启动作业可以让该作业忽略 <code>SIGHUP</code> , 其用法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup ping 127.0.0.1 &amp;</span><br><span class="line">[1] 21222</span><br><span class="line">nohup: ignoring input and appending output to <span class="string">'nohup.out'</span></span><br><span class="line"><span class="comment"># exec ping 127.0.0.1 &amp; 也可以实现类似的效果</span></span><br><span class="line"><span class="comment"># 但 nohup 会自动帮你处理输出重定向</span></span><br></pre></td></tr></table></figure>

<p>退出当前终端并在另一个终端执行查找 <code>ping</code> 进程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps -ef | awk <span class="string">'$8~/^ping/ &#123;print "PID:"$2", PPID:"$3&#125;'</span></span><br><span class="line">PID:21222, PPID:1  <span class="comment"># 变为孤儿进程继续运行</span></span><br></pre></td></tr></table></figure>

<p>为了防止后台作业阻塞, <code>nohup</code> 会让作业忽略输入, 并将所有输出默认重定向到 <code>~/nohup.out</code> 文件中, 我们可以手动进行输出重定向, 而且会自动帮我们将标准错误重定向到标准输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup ping 127.0.0.1 &gt; outfile &amp;</span><br><span class="line">[1] 22505</span><br><span class="line">ignoring input and redirecting stderr to stdout</span><br><span class="line"></span><br><span class="line">&gt; nohup ping 127.0.0.1 &amp;&gt; outfile &amp;</span><br><span class="line">[2] 22523</span><br></pre></td></tr></table></figure>

<p>但要注意, <code>nohup</code> 命令后不可以通过 <code>(...)</code> 的方式在 <code>subshell</code> 中执行命令, 这样做会导致解释器将 <code>nohup</code> 视为函数从而导致语法错误:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup (sleep 120; <span class="built_in">echo</span> <span class="string">"job done"</span>) &amp;  <span class="comment"># 这么写会报错</span></span><br><span class="line">&gt; nohup bash -c <span class="string">'sleep 120; echo "job done"'</span> &amp;  <span class="comment"># 可以正常执行</span></span><br><span class="line">[1] 25758</span><br><span class="line">&gt; pstree -ap $</span><br><span class="line">bash,23897</span><br><span class="line">  ├─bash,25758 -c sleep 120; <span class="built_in">echo</span> <span class="string">"job done"</span></span><br><span class="line">  │   └─sleep,25759 120</span><br><span class="line">  └─pstree,25764 -ap 23897</span><br></pre></td></tr></table></figure>

<h2 id="内置命令-disown"><a href="#内置命令-disown" class="headerlink" title="内置命令 disown"></a>内置命令 disown</h2><p><code>nohup</code> 的不足之处在于必须在程序运行前指定是否忽略 <code>SIGHUP</code> 信号, 如果我们希望对运行中的作业进行修改可以使用内置命令 <code>disown</code> , 其用法如下:</p>
<ul>
<li><code>disown %n</code> : 把编号为 <code>n</code> 的作业从列表中剥离, 这回该作业所有的输出消失, 而且无法进行作业控制.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; ping 127.0.0.1 &gt; /dev/null &amp;</span><br><span class="line">[1] 29748</span><br><span class="line">&gt; <span class="built_in">disown</span> %1</span><br><span class="line">&gt; <span class="built_in">jobs</span>  <span class="comment"># 没有输出</span></span><br><span class="line">&gt; ps -f 29748</span><br><span class="line">UID        PID  PPID  C STIME TTY      STAT   TIME CMD</span><br><span class="line">remilia  29748 28309  0 15:10 pts/3    S      0:00 ping 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出终端并在另一个终端中查看该进程</span></span><br><span class="line">&gt; ps -f 29748  <span class="comment"># 变为孤儿进程继续运行</span></span><br><span class="line">UID        PID  PPID  C STIME TTY      STAT   TIME CMD</span><br><span class="line">remilia  29748     1  0 15:10 ?        S      0:00 ping 127.0.0.1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>disown -h %n</code> : 让编号为 <code>n</code> 的作业忽略退出时产生的 <code>SIGHUP</code> , 这种方法不会从作业列表中删除该作业, 因此可以继续使用作业控制命令进行管理.</li>
<li><code>disown -r</code> : 从作业列表中剥离所有运行中的作业.</li>
<li><code>disown -a</code> :  从作业列表中剥离所有作业.</li>
</ul>
<p>该命令的一个缺点是不会自动进行输出重定向, 如果我们需要保存作业的输出可以使用 <code>gdb</code> 在程序运行时修改文件描述符的指向.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; python3 logerr.py &amp;</span><br><span class="line">&gt; sudo gdb -p &#96;pgrep python3&#96; </span><br><span class="line">(gdb) p close(2)  # 删除标准错误</span><br><span class="line">$1 &#x3D; 0</span><br><span class="line">(gdb) p creat(&quot;&#x2F;tmp&#x2F;pyout&quot;, 0600)  # 创建文件自动连接到标准错误</span><br><span class="line">$2 &#x3D; 2</span><br><span class="line">(gdb) q  # 选 yes</span><br><span class="line"></span><br><span class="line">&gt; sudo ls -l &#x2F;proc&#x2F;31586&#x2F;fd&#x2F;2</span><br><span class="line">l-wx------ 1 remilia remilia 64 Mar 22 15:36 &#x2F;proc&#x2F;31586&#x2F;fd&#x2F;2 -&gt; &#x2F;tmp&#x2F;pyout</span><br></pre></td></tr></table></figure>

<h2 id="选项-huponexit"><a href="#选项-huponexit" class="headerlink" title="选项 huponexit"></a>选项 huponexit</h2><p><code>huponexit</code> 是 <code>bash</code> 中的选项, 其用法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">shopt</span> huponexit  <span class="comment"># 查看选项是否开启</span></span><br><span class="line">&gt; <span class="built_in">shopt</span> -s huponexit  <span class="comment"># 开启选项</span></span><br></pre></td></tr></table></figure>

<p>开启该选项则会让该 <code>shell</code> 会话中的所有后台作业忽略由该会话退出时执行 <code>exit</code> 所产生的 <code>SIGHUP</code> , 其他方式传递来的 <code>SIGHUP</code> 则不会被忽略, <code>SIGHUP</code> 的传播过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会话 -- SIGHUP --&gt; bash ( huponexit ) -- SIGHUP --&gt; 作业</span><br></pre></td></tr></table></figure>

<p>如果 <code>bash</code> 中开启了 <code>huponexit</code> , 则在会话退出时不会给子进程(作业)分发 <code>SIGHUP</code> 信号.</p>
<h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><p>我们也可以通过让后台作业变为孤儿进程的方式实现忽略父 <code>shell</code> 传递来的 <code>SIGHUP</code> 信号:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subshell 没有 wait 他自己的后台任务因此提前退出</span></span><br><span class="line"><span class="comment"># 这种方式可以自定义重定向输出文件 但无法进行作业管理</span></span><br><span class="line">&gt; (ping 127.0.0.1 &gt;/dev/null &amp;)</span><br><span class="line">&gt; ps -f `pgrep ping` </span><br><span class="line">UID        PID  PPID  C STIME TTY      STAT   TIME CMD</span><br><span class="line">remilia    847     1  0 15:49 pts/4    S      0:00 ping 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>另外还有一些工具如 <code>screen</code> , <code>tmux</code> , <code>dtach</code> 等可以实现更高级的功能.</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul>
<li><a href="http://www.linuxplus.org/kb/x6756.html" target="_blank" rel="noopener">高级Bash脚本编程指南</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-bash-s-job-control-to-manage-foreground-and-background-processes" target="_blank" rel="noopener">How To Use Bash’s Job Control</a></li>
<li><a href="https://etbe.coker.com.au/2008/02/27/redirecting-output-from-a-running-process/" target="_blank" rel="noopener">Redirecting Output from a Running Process</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/" data-id="ck8oiuufn0006e6axbk6ydtp4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/06/bash/mechanism/%E5%88%9D%E5%A7%8B%E5%8C%96/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          bash/mechanism/初始化
        
      </div>
    </a>
  
  
    <a href="/2020/04/06/bash/mechanism/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">bash/mechanism/历史记录</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">bash/mechanism/信号处理</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A7%8D%E7%B1%BB/">bash/mechanism/命令的种类</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/">bash/mechanism/命令的执行方式</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/">bash/mechanism/自动补全</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%AD%90shell/">bash/mechanism/子shell</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>