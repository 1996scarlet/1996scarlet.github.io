<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>bash/mechanism/退出状态 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="退出状态程序的退出状态当一个程序结束时会向父进程报告自己的退出状态( exit status ). 通过传递 int 类型的变量给库函数 exit 或系统调用 _exit 可以设置当前程序的退出状态, 在 Linux 中, 通过 WEXITSTATUS 返回的退出状态的值域为 [0, 255] 之间的整数 . 如果传递的值不在这个范围内, 内核会自动帮你强转为 u_int8_t . 通过 wait">
<meta property="og:type" content="article">
<meta property="og:title" content="bash&#x2F;mechanism&#x2F;退出状态">
<meta property="og:url" content="http://yoursite.com/2020/04/06/bash/mechanism/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="退出状态程序的退出状态当一个程序结束时会向父进程报告自己的退出状态( exit status ). 通过传递 int 类型的变量给库函数 exit 或系统调用 _exit 可以设置当前程序的退出状态, 在 Linux 中, 通过 WEXITSTATUS 返回的退出状态的值域为 [0, 255] 之间的整数 . 如果传递的值不在这个范围内, 内核会自动帮你强转为 u_int8_t . 通过 wait">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-06T13:38:57.641Z">
<meta property="article:modified_time" content="2020-04-06T07:41:21.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-bash/mechanism/退出状态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      bash/mechanism/退出状态
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h1><h2 id="程序的退出状态"><a href="#程序的退出状态" class="headerlink" title="程序的退出状态"></a>程序的退出状态</h2><p>当一个程序结束时会向父进程报告自己的退出状态( <code>exit status</code> ). 通过传递 <code>int</code> 类型的变量给库函数 <code>exit</code> 或系统调用 <code>_exit</code> 可以设置当前程序的退出状态, 在 <code>Linux</code> 中, 通过 <code>WEXITSTATUS</code> 返回的退出状态的值域为 <code>[0, 255]</code> 之间的整数 . 如果传递的值不在这个范围内, 内核会自动帮你强转为 <code>u_int8_t</code> . 通过 <code>waitpid</code> 库函数可以得到子进程的退出状态, 其值存储在参数 <code>wstatus</code> 的低 <code>8</code> 位中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在 wait.h 中</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> WEXITSTATUS(status)	__WEXITSTATUS (status)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在 waitstatus.h 中</span></span><br><span class="line"><span class="comment">/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__WEXITSTATUS(status)	(((status) &amp; 0xff00) &gt;&gt; 8)</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子展示了如何使用 <code>waitpid</code> 及相关宏函数获取子进程的退出状态:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT_EXIT 10086</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHILD_EXIT -10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> wstatus;</span><br><span class="line">        <span class="comment">// 父进程等待子进程执行完毕, 用 WUNTRACED 选项追踪已结束的子进程</span></span><br><span class="line">        <span class="keyword">pid_t</span> child_pid = waitpid(pid, &amp;wstatus, WUNTRACED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(wstatus))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child exit status: %d\n"</span>, WEXITSTATUS(wstatus));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            perror(<span class="string">"Bad wait status\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(PARENT_EXIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程立即退出, 因此需要父进程设置 WUNTRACED</span></span><br><span class="line">        <span class="built_in">exit</span>(CHILD_EXIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理 fork 时出现的错误</span></span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行上例可以得到被强转后的状态码, 我们使用 <code>WIFEXITED</code> 判断等待的子进程是否执行成功, 然后对执行成功子进程使用 <code>WEXITSTATUS</code> 获取其退出状态. 对程序来说, 最终的退出状态就是主进程的退出状态.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc ecitcode.c;./a.out;<span class="built_in">echo</span> <span class="string">"Parent exit status: $?"</span></span><br><span class="line">Child <span class="built_in">exit</span> status: 246  <span class="comment"># -10 强转为 uint8</span></span><br><span class="line">Parent <span class="built_in">exit</span> status: 102  <span class="comment"># 10086 强转为 uint8</span></span><br></pre></td></tr></table></figure>

<p>在 <code>POSIX</code> 标准中规定退出状态 <code>0</code> 代表该程序正常退出, <code>1</code> 代表发生错误, 其他数字由程序自行规定, 因此在 <code>glibc</code> 的 <code>stdlib.h</code> 中仅定义了如下宏:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_FAILURE    1       <span class="comment">/* Failing exit status.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_SUCCESS    0       <span class="comment">/* Successful exit status.  */</span></span></span><br></pre></td></tr></table></figure>

<p>程序本身一般会在文档中事先约定每种退出状态代表的退出原因( <code>termination</code> ), 例如在 <code>ls</code> 的帮助文档中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls --<span class="built_in">help</span></span><br><span class="line">...其他内容...</span><br><span class="line">Exit status:  <span class="comment"># 退出状态</span></span><br><span class="line"> 0  <span class="keyword">if</span> OK,  <span class="comment"># 正常执行</span></span><br><span class="line"> 1  <span class="keyword">if</span> minor problems  <span class="comment"># 次要问题, 例如: 无法访问子目录</span></span><br><span class="line"> 2  <span class="keyword">if</span> serious trouble  <span class="comment"># 严重错误, 例如: 无法访问命令行参数</span></span><br><span class="line">...其他内容...</span><br></pre></td></tr></table></figure>

<h2 id="命令的退出状态"><a href="#命令的退出状态" class="headerlink" title="命令的退出状态"></a>命令的退出状态</h2><p>在 <code>bash</code> 中会记录所执行命令的退出状态, 可以通过 <code>$?</code> 获取最近执行的命令的退出状态. <code>bash</code> 自身的退出状态为执行的最后一条命令的退出状态, 也就等价于显式指定 <code>exit $?</code> . 如果没有执行任何命令就退出, 则 <code>bash</code> 的退出状态为 <code>0</code> , 要注意在 <code>bash</code> 中用 <code>0</code> 表示 <code>true</code> , 用非零表示 <code>false</code> .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 exit 显式指定退出状态</span></span><br><span class="line">&gt; bash</span><br><span class="line">&gt; <span class="built_in">exit</span> 98</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">98</span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么也不执行则退出状态为 0</span></span><br><span class="line">&gt; bash</span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># Ctrl + D 退出</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认为最后一条命令的退出状态</span></span><br><span class="line">&gt; bash</span><br><span class="line">&gt; ecasd</span><br><span class="line">ecasd: <span class="built_in">command</span> not found</span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># Ctrl + D 退出</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">127</span><br></pre></td></tr></table></figure>

<p>在 <code>bash</code> 中对不同种类命令的退出状态作出如下规定:</p>
<p><strong>内置命令:</strong> 由于内置命令执行时不需要启动额外的子进程, 因此需要用返回值模拟退出状态. 每个函数都定义了自己的退出状态, 例如: 内置命令 <code>source</code> 将脚本文件的最后一个命令的返回状态作为命令的返回状态. <code>bash</code> 中所有的内置命令都用退出状态 <code>2</code> 表示用法错误, 例如: 选项错误, 缺少参数.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> -+-  <span class="comment"># 错误的参数</span></span><br><span class="line">bash: <span class="built_in">cd</span>: -+: invalid option</span><br><span class="line"><span class="built_in">cd</span>: usage: <span class="built_in">cd</span> [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>外部命令:</strong> 外部命令的退出状态就是使用 <code>waitpid</code> 得到的子进程的退出状态, 如果子进程在执行过程被编号为 <code>N</code> 的信号所终止, 则得到的退出状态就为 <code>128+N</code> .</p>
<p><strong>Shell 函数:</strong> 定义 <code>shell</code> 函数时, 函数名与之前已定义的只读函数名相同则退出状态为 <code>1</code> , 当发生语法错误则退出状态为 <code>2</code> . 执行 <code>shell</code> 函数时, 函数中最后执行的一条命令的退出状态就是整个函数的退出状态.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二次定义只读函数报错</span></span><br><span class="line">&gt; <span class="function"><span class="title">func</span></span> () &#123; <span class="built_in">echo</span>; &#125;</span><br><span class="line">&gt; <span class="built_in">readonly</span> -f func</span><br><span class="line">&gt; func; <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">&gt; <span class="function"><span class="title">func</span></span> () &#123; <span class="built_in">echo</span> poi; &#125;</span><br><span class="line">bash: func: <span class="built_in">readonly</span> <span class="keyword">function</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数发生语法错误</span></span><br><span class="line">&gt; <span class="function"><span class="title">fune</span></span> () &#123;aa&#125;</span><br><span class="line">bash: syntax error near unexpected token <span class="string">'&#123;aa&#125;'</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的退出状态是最后执行的命令的退出状态</span></span><br><span class="line">&gt; <span class="function"><span class="title">funr</span></span> () &#123; <span class="built_in">echo</span>; <span class="built_in">return</span> 6; &#125;</span><br><span class="line">&gt; funr; <span class="built_in">echo</span> $?</span><br><span class="line">   <span class="comment"># echo 打印的空行</span></span><br><span class="line">6  <span class="comment"># return 6 是函数中最后执行的命令</span></span><br></pre></td></tr></table></figure>

<p><strong>表达式:</strong> 使用 <code>((...))</code> 或 <code>let</code> 修饰的表达式的退出状态取决于表达式的值, 如果表达式的值为 <code>0</code> 则退出状态为 <code>1</code> ; 如果表达式的值为非零, 则退出状态为 <code>0</code> .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">let</span> 0+0; <span class="built_in">echo</span> $?</span><br><span class="line">1  <span class="comment"># 表达式值为零</span></span><br><span class="line">&gt; ((7-5)); <span class="built_in">echo</span> $?</span><br><span class="line">0  <span class="comment"># 表达式值非零</span></span><br></pre></td></tr></table></figure>

<p><strong>命令列表:</strong> 用 <code>;</code> , <code>&amp;</code> , <code>&amp;&amp;</code> , <code>||</code> 连接命令被称为命令列表, 其中用 <code>&amp;&amp;</code> 和 <code>||</code> 连接的命令使用左关联( <code>left associativity</code> )模式执行列表中的命令. 整个命令列表的退出状态为最后一条命令的退出状态. 此外, <code>$( LISTS )</code> 以及流程控制结构如: <code>for</code> , <code>while</code> 等的返回状态也是结构中的命令列表的退出状态.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 功能: 能ping通baidu.com则输出 `baidu.com is up` ， 否则输出 `baidu.com is down` 。</span></span><br><span class="line">&gt; ping -c1 baidu.com &amp;&gt; /dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">'baidu.com is up'</span> || <span class="built_in">echo</span> <span class="string">'baidu.com is down'</span></span><br><span class="line">baidu.com is down</span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">0  <span class="comment"># 无论是否能 ping 通, 命令列表的退出状态都等于最后一条命令的退出状态</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!1INFo]<br>左关联模式被广泛应用于各种语言的逻辑运算符优化中. 对于逻辑与运算符 <code>&amp;&amp;</code> , 以 <code>eq1 &amp;&amp; eq2</code> 为例, 只有当两边都为 <code>True</code> 才会返回 <code>True</code> , 因此当 <code>eq1</code> 为 <code>False</code> 时, <code>eq2</code> 不会执行; 对于逻辑或运算符 <code>||</code> , 以 <code>eq1 || eq2</code> 为例, 只要两边有一个 <code>True</code> 就会返回 <code>True</code> , 因此当 <code>eq1</code> 为 <code>True</code> 时, <code>eq2</code> 不会执行。</p>
</blockquote>
<p><strong>脚本:</strong> 使用 <code>.</code> 或 <code>source</code> 运行脚本文件等同于在当前 <code>bash</code> 中执行代码块, 脚本中最后执行的命令的退出状态就是脚本的退出状态. 使用 <code>./脚本名</code> 或 <code>bash 脚本名</code> 的方式执行脚本文件等同于执行外部命令, 脚本的退出状态就是外部命令 <code>bash</code> 的退出状态.</p>
<blockquote>
<p>[!1WARN]<br>如果脚本中最后执行的命令是 <code>exit</code> , 那么使用 <code>.</code> 或 <code>source</code> 执行该脚本文件在执行结束后会退出当前 <code>bash</code> .</p>
</blockquote>
<p><strong>后台作业与协作进程:</strong> 使用不带选项的 <code>wait</code> 命令可以获得最后一个执行完毕的后台作业的退出状态, 如果使用 <code>wait -n &lt;jobsec&gt;</code> 可以获得指定后台作业的退出状态, 如果作业不存在则退出状态为 <code>127</code> . 使用 <code>coproc</code> 在 <code>sub shell</code> 中执行的命令的退出状态和后台作业一样可以被 <code>wait</code> 获取, <code>coproc</code> 自身的退出状态始终为 <code>0</code> .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; sleep 10; aad; &#125; &amp;</span><br><span class="line">[1] 558</span><br><span class="line">&gt; <span class="built_in">wait</span> -n 1</span><br><span class="line">[1]+  Exit 127                &#123; sleep 10; aad; &#125;</span><br><span class="line"></span><br><span class="line">&gt; coproc &#123; sleep 10; aad; &#125;</span><br><span class="line">[1] 558</span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">0  <span class="comment"># 这是 coproc 的执行结果</span></span><br><span class="line">&gt; <span class="built_in">jobs</span></span><br><span class="line">[1]+  Exit 127                coproc COPROC &#123; sleep 10; aad; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>管道命令:</strong> 默认情况下, 管道的退出状态取决于管道中最后一条命令的退出状态. 如果设置了 <code>set -o pipefail</code> , 那么只有在管道中的全部命令的退出状态为 <code>0</code> 时, 整个管道的退出状态才为 <code>0</code> , 否则就是最后一个非零的退出状态. 在管道前添加 <code>!</code> 符号可以对整个管道的退出状态取反. <code>bash</code> 中的特殊变量 <code>$PIPESTATUS</code> 以数组的形式存储最近执行的前台管道的退出状态, 要注意的是单个命令也会被记录, 也就是说 <code>${PIPESTATUS[0]}</code> 和 <code>$?</code> 是等价的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管道的退出状态是最后一条命令的退出状态</span></span><br><span class="line">&gt; ps | xxp 2&gt;/dev/null | cat; <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">&gt; <span class="built_in">set</span> -o pipefail </span><br><span class="line">&gt; ps | xxp 2&gt;/dev/null | cat; <span class="built_in">echo</span> $?</span><br><span class="line">127  <span class="comment"># 设置了 pipefail 因此得到最后一个非零退出状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道中每个命令的退出状态被按顺序记录在数组中</span></span><br><span class="line">&gt; easd 2&gt;/dev/null | ls /nou 2&gt;/dev/null | more 2&gt;/dev/null</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;PIPESTATUS[@]&#125;</span></span><br><span class="line">127 2 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不带管道符号的单个命令也会被记录</span></span><br><span class="line">&gt; ping asbasdasd 2&gt;/dev/null; <span class="built_in">echo</span> <span class="variable">$&#123;PIPESTATUS[0]&#125;</span></span><br><span class="line">2</span><br><span class="line">&gt; ping asbasdasd 2&gt;/dev/null; <span class="built_in">echo</span> $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://unix.stackexchange.com/questions/418784/what-is-the-min-and-max-values-of-exit-codes-in-linux" target="_blank" rel="noopener">Exit status range</a></li>
<li><a href="https://linux.die.net/man/1/bash" target="_blank" rel="noopener">Bash man page</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/" data-id="ck8oiuufo0008e6ax6az60w3c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/06/bash/mechanism/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          bash/mechanism/历史记录
        
      </div>
    </a>
  
  
    <a href="/2020/04/06/bash/mechanism/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">bash/mechanism/文件描述符与重定向</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">bash/mechanism/信号处理</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A7%8D%E7%B1%BB/">bash/mechanism/命令的种类</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/">bash/mechanism/命令的执行方式</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/">bash/mechanism/自动补全</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%AD%90shell/">bash/mechanism/子shell</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>