<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-bash/mechanism/信号处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">bash/mechanism/信号处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux-中的信号"><a href="#Linux-中的信号" class="headerlink" title="Linux 中的信号"></a>Linux 中的信号</h1><p>信号( <code>Signal</code> )是操作系统中常用的进程通信手段, 主要用来描述特定事件的发生, 进程接收到信号时有以下几种处理方式:</p>
<ul>
<li>捕获并自定义处理函数: 给 <code>signal</code> 系统调用传递自定义回调函数, 进程在接收到信号时会执行该回调函数.</li>
<li>忽略信号: 给 <code>signal</code> 系统调用传递 <code>SIG_IGN</code> , 内核会直接丢弃该信号, 因此目标进程不会收到该信号.</li>
<li>执行默认操作: 内核对每个信号定义了默认的处理方式, 如果已经给信号设置了忽略或自定义处理函数, 可以给 <code>signal</code> 系统调用传递 <code>SIG_DFL</code> 将该信号的处理方式恢复为默认.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, SIG_IGN);  <span class="comment">// 忽略信号</span></span><br><span class="line">signal(SIGTERM, SIG_DFL);  <span class="comment">// 恢复信号</span></span><br><span class="line">signal(SIGSTOP, m_handler);  <span class="comment">// 自定义信号</span></span><br></pre></td></tr></table></figure>

<p>在 <code>Linux</code> 中, 信号的发送依赖于 <code>sigqueue</code> , <code>kill</code> , <code>raise</code> 系统调用, 信号的处理状态被记录在目标进程的 <code>task_struct</code> 的 <code>signal</code> 变量中, 该变量的类型为 <code>sigset_t</code> , 每一位存储一个信号的处理状态, 因此又被称为信号位图( <code>signal bitmap</code> ). 处于产生( <code>generate</code> )和递送( <code>delivery</code> )之间的信号状态会被标记为未决( <code>pending</code> ). 当目标进程短时间内接收到大量重复的信号或使用 <code>sigpending</code> 系统调用阻塞某个信号时, 目标进程信号位图中该信号的状态就会变为未决. 在 <code>Linux 5.3.0</code> 中对处于未决状态的信号有两种处理策略:</p>
<ul>
<li>丢弃: 如果目标进程中某种信号的状态为<strong>未决或忽略</strong>, 内核会直接丢弃之后产生的所有该种信号, 直到该信号的状态改变. 这是早期的 <code>Unix</code> 系统中的处理策略, 为了保证兼容性, <code>Linux 5.3.0</code> 中编号为 <code>1-31</code> 的信号遵循丢弃处理策略, 即使用 <code>sigqueue</code> 发送这些信号, 它们也不会去排队. 因存在丢失信号的可能, 按丢失策略处理的信号被称为不可靠信号, 按照 <code>POSIX</code> 则被称为非实时信号.</li>
<li>排队: 在 <code>Linux</code> 中对信号的处理方式做了改进, 内核会在目标进程的 <code>task_struct</code> 的中维护一个信号队列, 如果内核接收到了一个信号, 且目标进程中该信号的状态为<strong>未决</strong>, 则会将这个新产生的信号放入目标进程的信号队列中, 这样只要挂起的信号个数没有超过内核设定的上限, 理论上就不会丢失. <code>Linux 5.3.0</code> 中编号为 <code>32-64</code> 的信号遵循排队处理策略, 因此又被称为可靠信号, 按照 <code>POSIX</code> 则被称为实时信号.</li>
</ul>
<h2 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h2><p>大多数 <code>Linux</code> 发行版可以通过 <code>man 7 signal</code> 查看当前系统中支持的信号种类, <code>kill -l</code> 可以查看所有信号及其对应的数字. 其中我们常用的有:</p>
<ul>
<li><code>(2) SIGINT</code> : 给处在前台的正在运行的进程发送的键盘中断信号, 终止( <code>interrupt</code> )其运行, 一般对应 <code>Ctrl + C</code> .</li>
<li><code>(19) SIGSTOP</code> : 不可忽略的暂停信号, 是一种以编程方式发送的信号.</li>
<li><code>(20) SIGTSTP</code> : 暂停信号, 将当前任务 <code>stop</code> 并放到后台, 把控制权交给 <code>shell</code> , 一般对应 <code>Ctrl + Z</code> </li>
<li><code>(9) SIGKILL</code> : 不可被被阻塞, 处理和忽略的信号, 一般用于强行杀死某个进程, <code>kill -9 &lt;pid&gt;</code> </li>
<li><code>(15) SIGTERM</code> : 程序结束( <code>terminate</code> )信号, 与 <code>SIGKILL</code> 不同的是该信号可以被阻塞和处理. 通常用来要求程序自己正常退出. <code>shell</code> 命令 <code>kill</code> 缺省产生这个信号。</li>
<li><code>(14) SIGALRM</code> : </li>
<li><code>(1) SIGHUP</code> : 本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一 <code>session</code> 内的各个作业, 这时它们与控制终端不再关联。 登录 <code>Linux</code> 时，系统会分配给登录用户一个终端( <code>Session</code> )。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 <code>Session</code> 。当用户退出 <code>Linux</code> 登录时，前台进程组和后台有对终端输出的进程将会收到 <code>SIGHUP</code> 信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</li>
</ul>
<h1 id="在-bash-中处理信号"><a href="#在-bash-中处理信号" class="headerlink" title="在 bash 中处理信号"></a>在 bash 中处理信号</h1><p><code>bash</code> 中的一个典型的应用场景是通过内置命令 <code>kill</code> 向指定进程发送信号, 默认发送 <code>SIGTERM</code> 信号. 例如: 退出所有名称为 <code>chrome</code> 的进程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">kill</span> `pgrep chrome` </span><br><span class="line">&gt; killall chrome</span><br><span class="line">&gt; <span class="built_in">kill</span> `ps -ef | grep chrome | awk <span class="string">'&#123; print $2 &#125;'</span>` </span><br><span class="line">&gt; <span class="built_in">kill</span> `pidof chrome`</span><br></pre></td></tr></table></figure>

<p>此外, 还可以使用 <code>trap</code> 对信号进行捕捉, 从而实现对特定信号的处理, 其语法如下.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> [COMMANDS] [SIGNALS]</span><br></pre></td></tr></table></figure>

<p><code>trap</code> 在捕捉到信号之后会执行设置的命令, 这里的命令可以是任何有效的Linux命令，或一个用户定义的函数. 在 <code>shell</code> 脚本中, <code>trap</code> 可以被用于在退出时清除临时文件, 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">tempfile=$(mktemp) || <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">'rm -f "$tempfile"'</span> EXIT</span><br></pre></td></tr></table></figure>

<p>另一种经典的用法是在守护进程中, 捕捉 <code>SIGHUP</code> 并重读配置文件, 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -r <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &lt;cfg-file-path&gt;"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID: $"</span></span><br><span class="line"></span><br><span class="line">CONFIG=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">read_config</span></span> () &#123; </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"reading cfg from <span class="variable">$CONFIG</span>"</span></span><br><span class="line">    <span class="built_in">source</span> <span class="string">"<span class="variable">$CONFIG</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read_config</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"read_config"</span> HUP</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line">    sleep 15</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>接下来我们可以在两个终端中进行测试:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端一</span></span><br><span class="line">&gt; bash remove_temp.sh ./config/cfg1 </span><br><span class="line">PID: 8807</span><br><span class="line">reading cfg from ./config/cfg1</span><br><span class="line">from cfg1</span><br><span class="line">reading cfg from ./config/cfg1</span><br><span class="line">after change</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端二</span></span><br><span class="line">&gt; cat &gt; cfg1 &lt;&lt; EOF</span><br><span class="line">var=<span class="string">"after change"</span></span><br><span class="line">EOF</span><br><span class="line">&gt; <span class="built_in">kill</span> -s HUP 8807</span><br></pre></td></tr></table></figure>

<p>通过 <code>trap</code> 命令也可以保存与重设信号, 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">trap</span> <span class="string">"printf BOOM"</span> INT</span><br><span class="line">&gt; ^CBOOM</span><br><span class="line">&gt; traps=$(<span class="built_in">trap</span>)  <span class="comment"># 保存信号处理方式</span></span><br><span class="line">&gt; <span class="built_in">trap</span> INT  <span class="comment"># 重设信号为默认处理方式</span></span><br><span class="line">&gt; ^C</span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="variable">$traps</span>  <span class="comment"># 加载信号处理方法</span></span><br><span class="line">&gt; ^CBOOM</span><br></pre></td></tr></table></figure>

<p><code>trap</code> 还支持捕捉多个信号, 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo Boom!"</span> SIGINT SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PPID</span> $</span><br><span class="line"><span class="keyword">while</span> : <span class="comment"># 冒号永远为真 也可作为占位符</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sleep 60</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><code>trap</code> 对大小写不敏感, 而且可以忽略前缀 <code>SIG</code> , 以下写法是等价的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trap &quot;echo 123&quot; SIGINT</span><br><span class="line">trap &quot;echo 123&quot; INT </span><br><span class="line">trap &quot;echo 123&quot; 2</span><br><span class="line">trap &quot;echo 123&quot; int </span><br><span class="line">trap &quot;echo 123&quot; Int</span><br></pre></td></tr></table></figure>

<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p><code>bash</code> 在执行外部命令时, 会提高前台任务的信号处理优先级, 当前台任务执行完毕或被终止时, <code>bash</code> 才会处理刚才收到的信号, 如下例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端一</span></span><br><span class="line">&gt; sleep 100  <span class="comment"># 这是个外部命令</span></span><br><span class="line"><span class="comment"># 在阻塞中...</span></span><br><span class="line"></span><br><span class="line">&gt;  <span class="comment"># 100秒之后打印了一个空行并显示提示符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端二</span></span><br><span class="line"><span class="comment"># 查看终端一的进程树</span></span><br><span class="line">&gt; pstree -ap 16003</span><br><span class="line">bash,16003</span><br><span class="line">  `-sleep,17249 100  <span class="comment"># 外部命令在子进程中执行</span></span><br><span class="line">&gt; <span class="built_in">kill</span> -s INT 16003  <span class="comment"># 让终端一的 bash 打印空行</span></span><br></pre></td></tr></table></figure>

<p>但要注意, 在 <code>shell</code> 中使用 <code>Ctrl + C</code> 会对整个进程组发送 <code>SIGINT</code> , 因此在上例中如果在终端一中使用 <code>Ctrl + C</code> 会导致 <code>sleep</code> 立即结束, 并打印一个空行. 我们也可以把前台任务放到后台来让 <code>bash</code> 优先处理信号, 但如果 <code>bash</code> 退出时仍有未完成的后台任务, 则这些任务会变为孤儿进程, 它们的父进程会变为 <code>PID=1</code> 的 <code>init</code> 进程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; (sleep 50 &amp; sleep 50 &amp; <span class="built_in">wait</span>)</span><br><span class="line"><span class="comment"># 进程树</span></span><br><span class="line">bash,15158</span><br><span class="line">  `-bash,7629</span><br><span class="line">      |-sleep,7630 50</span><br><span class="line">      `-sleep,7631 50</span><br><span class="line">&gt; <span class="built_in">kill</span> 7629</span><br><span class="line"><span class="comment"># 进程树</span></span><br><span class="line">bash,15158</span><br><span class="line">&gt; ps -ef | grep <span class="string">"sleep 50"</span></span><br><span class="line">remilia  11168     1  0 16:56 pts/2    00:00:00 sleep 50</span><br><span class="line">remilia  11169     1  0 16:56 pts/2    00:00:00 sleep 50</span><br><span class="line"><span class="comment"># 第三列是 PPID, 已经变成 1 了</span></span><br></pre></td></tr></table></figure>

<p>如果需要在进程退出时将后台任务也终止, 则需要记录后台任务的 <code>PID</code> 并在退出前将这些进程 <code>kill</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">BPIDARRAY=()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..9&#125;; <span class="keyword">do</span></span><br><span class="line">  sleep 20 &amp;</span><br><span class="line">  BPIDARRAY[<span class="variable">$i</span>]=$!</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">sleep 3</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"kill `echo <span class="variable">$&#123;BPIDARRAY[@]&#125;</span>` "</span> EXIT</span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure>

<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p><code>trap</code> 不仅可以捕捉定义在 <code>&lt;signal.h&gt;</code> 中的信号名或者数值, 还支持以下用法:</p>
<ul>
<li><code>trap -l</code> : 类似于 <code>kill -l</code> , 用于列出当前系统支持的所有信号.</li>
<li><code>trap -p</code> 或 <code>trap</code> : 列出通过trap设置的信号处理命令.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">trap</span> -p</span><br><span class="line"><span class="built_in">trap</span> -- <span class="string">'code'</span> EXIT</span><br><span class="line"><span class="built_in">trap</span> -- <span class="string">'echo SIGINT'</span> SIGINT</span><br></pre></td></tr></table></figure>

<ul>
<li><code>trap &quot;some code&quot; EXIT</code> : 仅在 <code>shell</code> 中可用的编号为 <code>0</code> 的特殊信号, 在 <code>bash</code> 中代表处理所有的退出情况, 而在标准 <code>shell</code> 中则用于捕捉 <code>exit</code> .</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; trap &quot;code&quot; EXIT</span><br><span class="line">&gt; ^D  # 退出终端的同时会打开 vscode</span><br></pre></td></tr></table></figure>

<ul>
<li><code>trap &quot;some code&quot; ERR</code> : 捕捉执行出现错误的命令, 在命令执行出现错误时执行预定义的代码块.</li>
<li><code>trap &quot;some code&quot; DEBUG</code> : 以调试模式执行命令时, 将在每个命令执行前执行预定义的代码块.</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><code>trap</code> 设置只作用于当前进程, 因此要注意除了通过 <code>.</code> 或 <code>source</code> 执行的脚本都会产生 <code>child shell</code> , 这些脚本中不会继承当前 <code>shell</code> 设置的 <code>trap</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">trap</span> <span class="string">"printf book"</span> 2</span><br><span class="line">&gt; ^Cbook</span><br><span class="line">&gt; bash -c <span class="string">"trap -p"</span>  <span class="comment"># 无输出</span></span><br><span class="line">&gt; bash</span><br><span class="line">&gt; ^C  <span class="comment"># 对子进程无效</span></span><br></pre></td></tr></table></figure>

<p>在函数中设置的 <code>trap</code> 也是全局生效的, 重复设置同一个信号则只有最后一次 <code>trap</code> 有效. 需要特别注意的是, 在 <code>bash</code> 脚本中或者非交互式 <code>bash shell</code> 中捕获 <code>SIGINT</code> 和 <code>SIGQUIT</code> 时最好按照如下方式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">'rm -f "$tempfile"; trap - INT; kill -s INT "$"'</span> INT</span><br></pre></td></tr></table></figure>

<p><code>bash</code> 在接收到退出信号时按照 <code>WCE (wait and cooperative exit)</code> 原则进行处理, 按下 <code>Ctrl + C</code> 时, 当前进程组都会收到 <code>SIGINT</code> , 这样就有以下几种情况(不考虑忽略信号的情况):</p>
<ul>
<li>前台子进程处理 <code>SIGINT</code> :<ul>
<li>处理信号然后自己 <code>kill</code> , 这样父 <code>bash</code> (调用者)就会接收到子进程通过信号非正常退出, 则立即退出当前脚本.</li>
<li>处理信号并用 <code>exit</code> 正常退出, 这样父 <code>bash</code> (调用者)就认为子进程正常执行完毕, 从而继续解释脚本.</li>
</ul>
</li>
<li>前台子进程不处理 <code>SIGINT</code> : 这种情况与处理信号并自己 <code>kill</code> 相似, 父 <code>bash</code> (调用者)会立即退出当前脚本.</li>
</ul>
<p>举例来说, 考虑下面这个脚本:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat ping_loop.sh</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 254` ;  <span class="keyword">do</span></span><br><span class="line">    ping -c 2 <span class="string">"192.168.1.<span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">&gt; bash ping_loop.sh</span><br><span class="line"><span class="comment"># 如果这样执行, 你需要按 254 次 Ctrl + C 才能完全退出</span></span><br><span class="line"><span class="comment"># 注意这个是 bash 的特性</span></span><br></pre></td></tr></table></figure>

<p>在上例中, 按下 <code>Ctrl + C</code> 时, <code>ping</code> 先收到 <code>SIGINT</code> 并处理然后正常退出, 之后 <code>bash</code> 也会收到 <code>SIGINT</code> 和上一条命令( <code>ping 192.168.0.1</code> )的退出状态, 发现正常退出因此继续解释之后的命令. 而对于 <code>sleep</code> 这种对 <code>SIGINT</code> 信号进行默认处理的命令, 情况则完全不同:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat sleep_loop.sh</span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$i</span>"</span> -le 100 ]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"%d "</span> <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">  i=$((i+1))</span><br><span class="line">  sleep 10</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">&gt; bash sleep_loop.sh</span><br><span class="line"><span class="comment"># 如果这样执行, 按一次 Ctrl + C 就可以退出脚本</span></span><br></pre></td></tr></table></figure>

<p>在上例中, 按下 <code>Ctrl + C</code> 时, <code>sleep</code> 先收到 <code>SIGINT</code> 并按照默认方式处理, 之后 <code>bash</code> 也会收到 <code>SIGINT</code> 和上一条命令( <code>sleep 10</code> )的退出状态, 发现 <code>sleep</code> 非正常退出因此 <code>bash</code> 立即退出. 我们可以通过更简单的命令加深理解:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; (ping 192.168.0.1; ping 192.168.0.2)</span><br><span class="line">bash,7744  </span><br><span class="line"> `-bash,24002  </span><br><span class="line">     `-ping,24011 192.168.0.1</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">kill</span> -2 24011 24002  <span class="comment"># 在另一个终端执行</span></span><br><span class="line"><span class="comment"># 由于 ping 会处理 SIGINT 并返回 0, 表示自己正常退出</span></span><br><span class="line"><span class="comment"># bash 24002 认为 ping 24026 正常退出就解释下一条命令</span></span><br><span class="line"><span class="comment"># 进程树会变成下面这样</span></span><br><span class="line">bash,7744  </span><br><span class="line"> `-bash,24002</span><br><span class="line">     `-ping,24026 192.168.0.2</span><br><span class="line"></span><br><span class="line">&gt; (sleep 50; sleep 50)</span><br><span class="line">bash,7744</span><br><span class="line">  `-bash,26053</span><br><span class="line">      `-sleep,26054 50</span><br><span class="line">&gt; <span class="built_in">kill</span> -2 26054 26053</span><br><span class="line"><span class="comment"># sleep 会以默认方式处理 SIGINT 信号</span></span><br><span class="line"><span class="comment"># 因此 bash 26053 会收到子进程因为 SIGINT 非正常退出的信息</span></span><br><span class="line"><span class="comment"># bash 26053 将立即退出</span></span><br></pre></td></tr></table></figure>

<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul>
<li><a href="http://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener">Signal Trap</a></li>
</ul>
<p><a href="http://redsymbol.net/articles/bash-exit-traps/" target="_blank" rel="noopener">How “Exit Traps” Can Make Your Bash Scripts Way More Robust And Reliable</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/" data-id="ck8oiuufn0005e6ax0au78hj8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/命令的种类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A7%8D%E7%B1%BB/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A7%8D%E7%B1%BB/">bash/mechanism/命令的种类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="命令的种类"><a href="#命令的种类" class="headerlink" title="命令的种类"></a>命令的种类</h1><p><code>Bash</code> 支持的命令包括以下三类：</p>
<ul>
<li><code>shell</code> 函数：按照 <code>shell</code> 编程的语法构造的可多次调用的代码块, 与其他语言不同的是, <code>shell</code> 中的函数没有形参列表, 但可以在调用函数时传递任意数量的参数, 函数内部通过 <code>$N</code> 的方式获取指定位置的参数. 我们可以用 <code>typeset -f</code> 命令查看当前 <code>shell</code> 中定义的所有函数函数, 通过下列命令可以直接显示函数名.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">typeset</span> -f | awk <span class="string">'$2~/\(\)/ &#123; print $1 &#125;'</span></span><br><span class="line">&gt; <span class="built_in">typeset</span> -f | sed -En <span class="string">"s/(.*) \(\)/\1/ p"</span></span><br><span class="line">&gt; <span class="built_in">typeset</span> -f | grep <span class="string">"()"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>内置命令：由 <code>shell</code> 在源代码层面提供的命令，而不是存在于文件系统中的某个可执行文件。例如，用于进入或者切换目录的 <code>cd</code> 命令并不是某个外部文件，在执行内置命令时不需要 <code>fork</code> 子进程，也不需要使用 <code>exec</code> 加载外部可执行文件，因此不会触发磁盘 <code>I/O</code> ，执行内置命令相当于执行当前 <code>shell</code> 源代码中的一个函数。我们可以用 <code>type</code> 判断一个命令是否为内置命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span> <span class="built_in">cd</span> <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">alias</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">&gt; compgen -b  <span class="comment"># 显示所有内置命令</span></span><br></pre></td></tr></table></figure>

<ul>
<li>外部可执行文件：一般被称为程序( <code>program</code> ), 是存储在外部存储设备上的可执行文件. <code>bash</code> 会在当前路径和 <code>PATH</code> 环境变量中的路径下寻找可执行文件, <code>bash</code> 使用哈希表记住可执行文件的完整路径名, 用于避免多次重复的全局搜索.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; man</span><br><span class="line">What manual page <span class="keyword">do</span> you want?</span><br><span class="line">&gt; <span class="built_in">type</span> man</span><br><span class="line">man is hashed (/usr/bin/man)  <span class="comment"># 再次访问就已经被哈希表缓存了</span></span><br><span class="line">&gt; <span class="built_in">which</span> man  <span class="comment"># 查看外部命令的路径</span></span><br><span class="line">/usr/bin/man</span><br></pre></td></tr></table></figure>

<p>在进行命令查询时, 优先级为 <code>shell 函数 &gt; 内置命令 &gt; 外部可执行文件</code> , 例如 <code>Ubuntu</code> 系统中 <code>/usr/bin/</code> 路径下自带 <code>GNU</code> 标准 <code>echo</code> 可执行文件, 而 <code>bash</code> 中也存在内置命令 <code>echo</code> , 按照命令查询顺序, 在 <code>bash</code> 中使用 <code>echo</code> 时会优先执行内置命令. 在 <code>bash</code> 中还可以使用 <code>alias</code> 为常用的命令添加别名, 别名的优先级要高于以上三种常规命令.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">which</span> ls</span><br><span class="line">/usr/bin/ls  <span class="comment"># 是外部命令</span></span><br><span class="line">&gt; <span class="built_in">type</span> ls</span><br><span class="line">ls is aliased to `ls --color=auto<span class="string">'   # 别名 ls 会自动显示颜色</span></span><br></pre></td></tr></table></figure>

<h1 id="命令的结构"><a href="#命令的结构" class="headerlink" title="命令的结构"></a>命令的结构</h1><h2 id="实现-shell-函数命令"><a href="#实现-shell-函数命令" class="headerlink" title="实现 shell 函数命令"></a>实现 shell 函数命令</h2><p>在 <code>bash</code> 中定义函数时, 关键字 <code>function</code> 可以省略, 函数内部可能包括内置命令, 外部命令, 变量, 数组, 关键字等, 其本质就是代码块, 不过有一些类似其他语言中函数的特性. 函数的其他语法细节可以参考<a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Functions.html" target="_blank" rel="noopener">GNU Bash 手册</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> pskill()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 这个函数的功能类似于 pkill</span></span><br><span class="line">    <span class="comment"># 判断参数数量是否正确</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Usage: pskill &lt;proc-name&gt;"</span></span><br><span class="line">        <span class="built_in">return</span> -127</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> pid  <span class="comment"># 设置作用域为本地, 也就是代码块内部</span></span><br><span class="line">    <span class="comment"># 不这么写就默认是全局变量</span></span><br><span class="line"></span><br><span class="line">    pid=$(ps -ax | grep <span class="variable">$1</span> | grep -v grep | awk <span class="string">'&#123; print $1 &#125;'</span>)</span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid</span> &amp;  <span class="comment"># 提交作业</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"killing <span class="variable">$1</span> (process <span class="variable">$pid</span>)..."</span></span><br><span class="line">    <span class="built_in">wait</span>  <span class="comment"># 等待作业完成</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"slaughtered."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比其他语言, <code>bash</code> 中的函数没有固定的形参列表, 好处是其调用形式更像普通的命令, 例如: <code>函数名 &lt;参数1&gt; &lt;参数2&gt; ...</code> , 但坏处是如果不在函数内部对参数的数量以及合法性进行判断, 很容易产生严重的运行时错误.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; pskill</span><br><span class="line">Usage: pskill &lt;proc-name&gt;</span><br><span class="line"></span><br><span class="line">&gt; xclock &amp;</span><br><span class="line">[1] 3003</span><br><span class="line">&gt; pskill xclock</span><br><span class="line">[2] 3043</span><br><span class="line">killing xclock (process 3003)...[1]-  Killed                  xclock</span><br><span class="line">[2]+  Done                    <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">slaughtered.</span><br></pre></td></tr></table></figure>

<h2 id="实现内置命令"><a href="#实现内置命令" class="headerlink" title="实现内置命令"></a>实现内置命令</h2><p>本节使用 <code>5.0</code> 版本的 <code>GUN bash</code> 源代码进行讲解, 在修改源代码之前, 建议先确认你的环境是否能够成功配置并编译 <code>bash</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git <span class="built_in">clone</span> https://git.savannah.gnu.org/git/bash.git</span><br><span class="line">&gt; ./configure</span><br><span class="line">&gt; make  <span class="comment"># 成功则会在当前目录下生成可执行文件</span></span><br></pre></td></tr></table></figure>

<p>现在我们开始实现一个名为 <code>scarlet</code> 的内置命令, 其功能和 <code>eval</code> 相同. 我们令源代码根目录为 <code>$(topdir)</code> , 首先我们要在 <code>$(topdir)/builtins/</code> 路径下建立 <code>scarlet.def</code> 文件并填充如下内容:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$PRODUCES</span> scarlet.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$BUILTIN</span> scarlet</span><br><span class="line"><span class="variable">$FUNCTION</span> scarlet_builtin</span><br><span class="line"><span class="variable">$SHORT_DOC</span> scarlet [arg ...]</span><br><span class="line">Execute arguments as a shell <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Combine ARGs into a single string, use the result as input to the shell,</span><br><span class="line">and execute the resulting commands.</span><br><span class="line"></span><br><span class="line">Exit Status:</span><br><span class="line">Returns <span class="built_in">exit</span> status of <span class="built_in">command</span> or success <span class="keyword">if</span> <span class="built_in">command</span> is null.</span><br><span class="line"><span class="variable">$END</span></span><br></pre></td></tr></table></figure>

<p><code>*.def</code> 格式的文件是 <code>bash</code> 内置命令的预定义文件, 在 <code>make</code> 过程中会先将 <code>$(topdir)/builtins/mkbuiltins.c</code> 文件编译为 <code>mkbuiltins</code> , 然后使用这个工具将预定义文件转换为 <code>*.c</code> 格式, 再通过 <code>gcc</code> 将其编译为 <code>*.o</code> 文件, 并最终成为 <code>bash</code> 可执行文件的一部分. 使用 <code>mkbuiltins</code> 可以显著提升内置命令的编写效率, 因为这个工具帮你自动生成了大部分重复的代码, 你只需要配置以下几个变量:</p>
<ul>
<li><code>$PRODUCES</code> : 用于表示转换源代码目标文件的名字, 变量的命名注意不要与其他文件冲突, 之后我们还要在 <code>Makefile.in</code> 中进行配置.</li>
<li><code>$BUILTIN</code> : 最终可调用的内置命令的名字, 命名规则与函数相同.</li>
<li><code>$FUNCTION</code> : 命令的入口函数名, 命名规则与函数相同, 这个函数的实现也需要在这个文件中.</li>
<li><code>$SHORT_DOC</code> : 命令的简要帮助文档, 以 <code>$END</code> 作为结束标志, 这部分内容在运行时可以通过 <code>命令 --help</code> 的方式查看.</li>
</ul>
<p>接下来在我们需要在 <code>scarlet.def</code> 文件中实现 <code>scarlet_builtin</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (HAVE_UNISTD_H)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">ifdef</span> _MINIX</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../shell.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bashgetopt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">scarlet_builtin (<span class="built_in">list</span>)</span><br><span class="line">     WORD_LIST *<span class="built_in">list</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (no_options (<span class="built_in">list</span>))</span><br><span class="line">    <span class="keyword">return</span> (EX_USAGE);</span><br><span class="line">  <span class="built_in">list</span> = loptend;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">list</span> ? evalstring (string_list (<span class="built_in">list</span>), <span class="string">"scarlet"</span>, SEVAL_NOHIST) : EXECUTION_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先引用了必要的头文件用于处理输入, 主要是为了使用 <code>WORD_LIST</code> 这个数据结构, 它存储了 <code>bash</code> 对当前命令的分词结果 <code>token</code> , 然后通过 <code>evalstring</code> 解析并执行这些 <code>token</code> . 可以看出, 我们在编写这个内置命令时只需要处理核心业务逻辑, 其他部分都可以通过合理配置预定义变量让 <code>mkbuiltins</code> 自动生成. 接下来需要在 <code>Makefile.in</code> 文件中对编译生成的中间文件和引用的头文件进行配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEFSRC 变量中添加</span></span><br><span class="line">$(srcdir)/scarlet.def</span><br><span class="line"></span><br><span class="line"><span class="comment"># OFILES 变量中添加</span></span><br><span class="line">scarlet.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># dependencies 区域中添加</span></span><br><span class="line">scarlet.o: scarlet.def</span><br><span class="line"></span><br><span class="line"><span class="comment"># def files 区域中添加</span></span><br><span class="line">scarlet.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h</span><br><span class="line">scarlet.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h</span><br><span class="line">scarlet.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h</span><br><span class="line">scarlet.o: $(topdir)/subst.h $(topdir)/externs.h  $(topdir)/sig.h</span><br><span class="line">scarlet.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h</span><br><span class="line">scarlet.o: $(BASHINCDIR)/maxpath.h ../pathnames.h</span><br></pre></td></tr></table></figure>

<p>处理完所有的预定义文件后, <code>mkbuiltins</code> 还会生成用于存放所有内置命令接口的 <code>builtins.c</code> 和 <code>builtext.h</code> 文件, 我们现在可以重新配置并编译 <code>bash</code> 来测试我们实现的内置命令 <code>scarlet</code> 的效果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意要进到 $(topdir)/ 路径下</span></span><br><span class="line">&gt; make clean; ./configure; make -j6</span><br><span class="line">&gt; ./bash</span><br><span class="line">&gt; scarlet --<span class="built_in">help</span></span><br><span class="line">scarlet: scarlet [arg ...]</span><br><span class="line">    Execute arguments as a shell <span class="built_in">command</span>.</span><br><span class="line">    </span><br><span class="line">    Combine ARGs into a single string, use the result as input to the shell,</span><br><span class="line">    and execute the resulting commands.</span><br><span class="line">    </span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns <span class="built_in">exit</span> status of <span class="built_in">command</span> or success <span class="keyword">if</span> <span class="built_in">command</span> is null.</span><br><span class="line">&gt; VAR=1; POINT+VAR</span><br><span class="line">&gt; <span class="built_in">echo</span> \<span class="variable">$POINT</span></span><br><span class="line"><span class="variable">$VAR</span>  <span class="comment"># bash 默认只解释一次变量名</span></span><br><span class="line">&gt; scarlet <span class="built_in">echo</span> \<span class="variable">$POINT</span></span><br><span class="line">1  <span class="comment"># 自定义内置变量实现了 eval 多次解释的功能</span></span><br></pre></td></tr></table></figure>

<h2 id="实现外部命令"><a href="#实现外部命令" class="headerlink" title="实现外部命令"></a>实现外部命令</h2><p>大部分外部命令都是事先编译好的二进制可执行文件, 在 <code>bash</code> 中会通过 <code>fork-exec</code> 模式处理每个外部命令, 也就是说外部命令都运行在子进程中. 在本节将通过实现 <code>ls</code> 命令的最基础功能来讲解外部命令的实现过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span>  <span class="comment">// 这个头文件需要自己去 APUE 网站下载</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;  // 路径处理相关头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dp;  <span class="comment">// 路径数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span>  <span class="comment">// 存放文件或路径inode, 名称等内容的数据结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数数量是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage: myls directory_name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断传入的目录是否能打开</span></span><br><span class="line">    <span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历指定目录</span></span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子来自于《Unix环境高级编程》第一章, 实现一个命令至少需要完成输出参数处理, 核心业务逻辑, 结果输出三个部分. 而且建议在参数输入错误时给出用法提示, 在运行出现问题时应该给出适当的退出状态码. 现在我们编译这个命令并将其放到 <code>PATH</code> 包含的目录中, 然后测试这个命令是否能正确输出.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo gcc 1/ls.c -o /usr/bin/myls</span><br><span class="line">&gt; myls  <span class="comment"># 用法错误</span></span><br><span class="line">usage: myls directory_name  <span class="comment"># 给出提示</span></span><br><span class="line">&gt; myls .  <span class="comment"># 遍历当前路径</span></span><br><span class="line">snap</span><br><span class="line">peko</span><br><span class="line">pekosh</span><br><span class="line">R</span><br><span class="line">.ssh</span><br></pre></td></tr></table></figure>

<h1 id="脚本的结构"><a href="#脚本的结构" class="headerlink" title="脚本的结构"></a>脚本的结构</h1><p>在 <code>bash</code> 中, 脚本就是命令和控制逻辑的组合, 我们先看一个普通脚本的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is information provided by mysystem.sh.  Program starts now."</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"Hello, <span class="variable">$USER</span>\n\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"Today's date is `date` , this is week `date +"</span>%V<span class="string">"` .\n\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"These users are currently connected:"</span></span><br><span class="line">w | cut -d <span class="string">" "</span> -f 1 - | grep -v USER | sort -u</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"This is `uname -s` running on a `uname -m` processor.\n\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is the uptime information:"</span></span><br><span class="line">uptime</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"That's all folks!"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>#!/bin/bash</code> 是 <code>Shebang</code> , 用于指定这个脚本的解释器。</li>
<li><code>/usr/bin/clear</code> 是一个外部命令，用于清除当前 <code>shell</code> 中的输出信息。</li>
<li><code>echo</code> 和 <code>printf</code> 都是 <code>bash</code> 的内置命令，不同的是 <code>echo</code> 始终以 <code>0</code> 状态码退出（退出状态永远是成功），并且仅在标准输出上打印参数，然后打印行尾字符，而 <code>printf</code> 允许定义格式字符串，并在失败时给出非零的退出状态代码。</li>
<li><code>USER</code> 是一个变量，用于存储当前用户的名字，需要使用`# 命令的种类</li>
</ul>
<p><code>Bash</code> 支持的命令包括以下三类：</p>
<ul>
<li><code>shell</code> 函数：按照 <code>shell</code> 编程的语法构造的可多次调用的代码块, 与其他语言不同的是, <code>shell</code> 中的函数没有形参列表, 但可以在调用函数时传递任意数量的参数, 函数内部通过 <code>$N</code> 的方式获取指定位置的参数. 我们可以用 <code>typeset -f</code> 命令查看当前 <code>shell</code> 中定义的所有函数函数, 通过下列命令可以直接显示函数名.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">typeset</span> -f | awk <span class="string">'$2~/\(\)/ &#123; print $1 &#125;'</span></span><br><span class="line">&gt; <span class="built_in">typeset</span> -f | sed -En <span class="string">"s/(.*) \(\)/\1/ p"</span></span><br><span class="line">&gt; <span class="built_in">typeset</span> -f | grep <span class="string">"()"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>内置命令：由 <code>shell</code> 在源代码层面提供的命令，而不是存在于文件系统中的某个可执行文件。例如，用于进入或者切换目录的 <code>cd</code> 命令并不是某个外部文件，在执行内置命令时不需要 <code>fork</code> 子进程，也不需要使用 <code>exec</code> 加载外部可执行文件，因此不会触发磁盘 <code>I/O</code> ，执行内置命令相当于执行当前 <code>shell</code> 源代码中的一个函数。我们可以用 <code>type</code> 判断一个命令是否为内置命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span> <span class="built_in">cd</span> <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">alias</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">&gt; compgen -b  <span class="comment"># 显示所有内置命令</span></span><br></pre></td></tr></table></figure>

<ul>
<li>外部可执行文件：一般被称为程序( <code>program</code> ), 是存储在外部存储设备上的可执行文件. <code>bash</code> 会在当前路径和 <code>PATH</code> 环境变量中的路径下寻找可执行文件, <code>bash</code> 使用哈希表记住可执行文件的完整路径名, 用于避免多次重复的全局搜索.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; man</span><br><span class="line">What manual page <span class="keyword">do</span> you want?</span><br><span class="line">&gt; <span class="built_in">type</span> man</span><br><span class="line">man is hashed (/usr/bin/man)  <span class="comment"># 再次访问就已经被哈希表缓存了</span></span><br><span class="line">&gt; <span class="built_in">which</span> man  <span class="comment"># 查看外部命令的路径</span></span><br><span class="line">/usr/bin/man</span><br></pre></td></tr></table></figure>

<p>在进行命令查询时, 优先级为 <code>shell 函数 &gt; 内置命令 &gt; 外部可执行文件</code> , 例如 <code>Ubuntu</code> 系统中 <code>/usr/bin/</code> 路径下自带 <code>GNU</code> 标准 <code>echo</code> 可执行文件, 而 <code>bash</code> 中也存在内置命令 <code>echo</code> , 按照命令查询顺序, 在 <code>bash</code> 中使用 <code>echo</code> 时会优先执行内置命令. 在 <code>bash</code> 中还可以使用 <code>alias</code> 为常用的命令添加别名, 别名的优先级要高于以上三种常规命令.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">which</span> ls</span><br><span class="line">/usr/bin/ls  <span class="comment"># 是外部命令</span></span><br><span class="line">&gt; <span class="built_in">type</span> ls</span><br><span class="line">ls is aliased to `ls --color=auto<span class="string">'   # 别名 ls 会自动显示颜色</span></span><br></pre></td></tr></table></figure>

<h1 id="命令的结构-1"><a href="#命令的结构-1" class="headerlink" title="命令的结构"></a>命令的结构</h1><h2 id="实现-shell-函数命令-1"><a href="#实现-shell-函数命令-1" class="headerlink" title="实现 shell 函数命令"></a>实现 shell 函数命令</h2><p>在 <code>bash</code> 中定义函数时, 关键字 <code>function</code> 可以省略, 函数内部可能包括内置命令, 外部命令, 变量, 数组, 关键字等, 其本质就是代码块, 不过有一些类似其他语言中函数的特性. 函数的其他语法细节可以参考<a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Functions.html" target="_blank" rel="noopener">GNU Bash 手册</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> pskill()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 这个函数的功能类似于 pkill</span></span><br><span class="line">    <span class="comment"># 判断参数数量是否正确</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Usage: pskill &lt;proc-name&gt;"</span></span><br><span class="line">        <span class="built_in">return</span> -127</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> pid  <span class="comment"># 设置作用域为本地, 也就是代码块内部</span></span><br><span class="line">    <span class="comment"># 不这么写就默认是全局变量</span></span><br><span class="line"></span><br><span class="line">    pid=$(ps -ax | grep <span class="variable">$1</span> | grep -v grep | awk <span class="string">'&#123; print $1 &#125;'</span>)</span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid</span> &amp;  <span class="comment"># 提交作业</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"killing <span class="variable">$1</span> (process <span class="variable">$pid</span>)..."</span></span><br><span class="line">    <span class="built_in">wait</span>  <span class="comment"># 等待作业完成</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"slaughtered."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比其他语言, <code>bash</code> 中的函数没有固定的形参列表, 好处是其调用形式更像普通的命令, 例如: <code>函数名 &lt;参数1&gt; &lt;参数2&gt; ...</code> , 但坏处是如果不在函数内部对参数的数量以及合法性进行判断, 很容易产生严重的运行时错误.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; pskill</span><br><span class="line">Usage: pskill &lt;proc-name&gt;</span><br><span class="line"></span><br><span class="line">&gt; xclock &amp;</span><br><span class="line">[1] 3003</span><br><span class="line">&gt; pskill xclock</span><br><span class="line">[2] 3043</span><br><span class="line">killing xclock (process 3003)...[1]-  Killed                  xclock</span><br><span class="line">[2]+  Done                    <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">slaughtered.</span><br></pre></td></tr></table></figure>

<h2 id="实现内置命令-1"><a href="#实现内置命令-1" class="headerlink" title="实现内置命令"></a>实现内置命令</h2><p>本节使用 <code>5.0</code> 版本的 <code>GUN bash</code> 源代码进行讲解, 在修改源代码之前, 建议先确认你的环境是否能够成功配置并编译 <code>bash</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git <span class="built_in">clone</span> https://git.savannah.gnu.org/git/bash.git</span><br><span class="line">&gt; ./configure</span><br><span class="line">&gt; make  <span class="comment"># 成功则会在当前目录下生成可执行文件</span></span><br></pre></td></tr></table></figure>

<p>现在我们开始实现一个名为 <code>scarlet</code> 的内置命令, 其功能和 <code>eval</code> 相同. 我们令源代码根目录为 <code>$(topdir)</code> , 首先我们要在 <code>$(topdir)/builtins/</code> 路径下建立 <code>scarlet.def</code> 文件并填充如下内容:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$PRODUCES</span> scarlet.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$BUILTIN</span> scarlet</span><br><span class="line"><span class="variable">$FUNCTION</span> scarlet_builtin</span><br><span class="line"><span class="variable">$SHORT_DOC</span> scarlet [arg ...]</span><br><span class="line">Execute arguments as a shell <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Combine ARGs into a single string, use the result as input to the shell,</span><br><span class="line">and execute the resulting commands.</span><br><span class="line"></span><br><span class="line">Exit Status:</span><br><span class="line">Returns <span class="built_in">exit</span> status of <span class="built_in">command</span> or success <span class="keyword">if</span> <span class="built_in">command</span> is null.</span><br><span class="line"><span class="variable">$END</span></span><br></pre></td></tr></table></figure>

<p><code>*.def</code> 格式的文件是 <code>bash</code> 内置命令的预定义文件, 在 <code>make</code> 过程中会先将 <code>$(topdir)/builtins/mkbuiltins.c</code> 文件编译为 <code>mkbuiltins</code> , 然后使用这个工具将预定义文件转换为 <code>*.c</code> 格式, 再通过 <code>gcc</code> 将其编译为 <code>*.o</code> 文件, 并最终成为 <code>bash</code> 可执行文件的一部分. 使用 <code>mkbuiltins</code> 可以显著提升内置命令的编写效率, 因为这个工具帮你自动生成了大部分重复的代码, 你只需要配置以下几个变量:</p>
<ul>
<li><code>$PRODUCES</code> : 用于表示转换源代码目标文件的名字, 变量的命名注意不要与其他文件冲突, 之后我们还要在 <code>Makefile.in</code> 中进行配置.</li>
<li><code>$BUILTIN</code> : 最终可调用的内置命令的名字, 命名规则与函数相同.</li>
<li><code>$FUNCTION</code> : 命令的入口函数名, 命名规则与函数相同, 这个函数的实现也需要在这个文件中.</li>
<li><code>$SHORT_DOC</code> : 命令的简要帮助文档, 以 <code>$END</code> 作为结束标志, 这部分内容在运行时可以通过 <code>命令 --help</code> 的方式查看.</li>
</ul>
<p>接下来在我们需要在 <code>scarlet.def</code> 文件中实现 <code>scarlet_builtin</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (HAVE_UNISTD_H)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">ifdef</span> _MINIX</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../shell.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bashgetopt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">scarlet_builtin (<span class="built_in">list</span>)</span><br><span class="line">     WORD_LIST *<span class="built_in">list</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (no_options (<span class="built_in">list</span>))</span><br><span class="line">    <span class="keyword">return</span> (EX_USAGE);</span><br><span class="line">  <span class="built_in">list</span> = loptend;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">list</span> ? evalstring (string_list (<span class="built_in">list</span>), <span class="string">"scarlet"</span>, SEVAL_NOHIST) : EXECUTION_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先引用了必要的头文件用于处理输入, 主要是为了使用 <code>WORD_LIST</code> 这个数据结构, 它存储了 <code>bash</code> 对当前命令的分词结果 <code>token</code> , 然后通过 <code>evalstring</code> 解析并执行这些 <code>token</code> . 可以看出, 我们在编写这个内置命令时只需要处理核心业务逻辑, 其他部分都可以通过合理配置预定义变量让 <code>mkbuiltins</code> 自动生成. 接下来需要在 <code>Makefile.in</code> 文件中对编译生成的中间文件和引用的头文件进行配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEFSRC 变量中添加</span></span><br><span class="line">$(srcdir)/scarlet.def</span><br><span class="line"></span><br><span class="line"><span class="comment"># OFILES 变量中添加</span></span><br><span class="line">scarlet.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># dependencies 区域中添加</span></span><br><span class="line">scarlet.o: scarlet.def</span><br><span class="line"></span><br><span class="line"><span class="comment"># def files 区域中添加</span></span><br><span class="line">scarlet.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h</span><br><span class="line">scarlet.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h</span><br><span class="line">scarlet.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h</span><br><span class="line">scarlet.o: $(topdir)/subst.h $(topdir)/externs.h  $(topdir)/sig.h</span><br><span class="line">scarlet.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h</span><br><span class="line">scarlet.o: $(BASHINCDIR)/maxpath.h ../pathnames.h</span><br></pre></td></tr></table></figure>

<p>处理完所有的预定义文件后, <code>mkbuiltins</code> 还会生成用于存放所有内置命令接口的 <code>builtins.c</code> 和 <code>builtext.h</code> 文件, 我们现在可以重新配置并编译 <code>bash</code> 来测试我们实现的内置命令 <code>scarlet</code> 的效果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意要进到 $(topdir)/ 路径下</span></span><br><span class="line">&gt; make clean; ./configure; make -j6</span><br><span class="line">&gt; ./bash</span><br><span class="line">&gt; scarlet --<span class="built_in">help</span></span><br><span class="line">scarlet: scarlet [arg ...]</span><br><span class="line">    Execute arguments as a shell <span class="built_in">command</span>.</span><br><span class="line">    </span><br><span class="line">    Combine ARGs into a single string, use the result as input to the shell,</span><br><span class="line">    and execute the resulting commands.</span><br><span class="line">    </span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns <span class="built_in">exit</span> status of <span class="built_in">command</span> or success <span class="keyword">if</span> <span class="built_in">command</span> is null.</span><br><span class="line">&gt; VAR=1; POINT+VAR</span><br><span class="line">&gt; <span class="built_in">echo</span> \<span class="variable">$POINT</span></span><br><span class="line"><span class="variable">$VAR</span>  <span class="comment"># bash 默认只解释一次变量名</span></span><br><span class="line">&gt; scarlet <span class="built_in">echo</span> \<span class="variable">$POINT</span></span><br><span class="line">1  <span class="comment"># 自定义内置变量实现了 eval 多次解释的功能</span></span><br></pre></td></tr></table></figure>

<h2 id="实现外部命令-1"><a href="#实现外部命令-1" class="headerlink" title="实现外部命令"></a>实现外部命令</h2><p>大部分外部命令都是事先编译好的二进制可执行文件, 在 <code>bash</code> 中会通过 <code>fork-exec</code> 模式处理每个外部命令, 也就是说外部命令都运行在子进程中. 在本节将通过实现 <code>ls</code> 命令的最基础功能来讲解外部命令的实现过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span>  <span class="comment">// 这个头文件需要自己去 APUE 网站下载</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;  // 路径处理相关头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dp;  <span class="comment">// 路径数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span>  <span class="comment">// 存放文件或路径inode, 名称等内容的数据结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数数量是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage: myls directory_name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断传入的目录是否能打开</span></span><br><span class="line">    <span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历指定目录</span></span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子来自于《Unix环境高级编程》第一章, 实现一个命令至少需要完成输出参数处理, 核心业务逻辑, 结果输出三个部分. 而且建议在参数输入错误时给出用法提示, 在运行出现问题时应该给出适当的退出状态码. 现在我们编译这个命令并将其放到 <code>PATH</code> 包含的目录中, 然后测试这个命令是否能正确输出.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo gcc 1/ls.c -o /usr/bin/myls</span><br><span class="line">&gt; myls  <span class="comment"># 用法错误</span></span><br><span class="line">usage: myls directory_name  <span class="comment"># 给出提示</span></span><br><span class="line">&gt; myls .  <span class="comment"># 遍历当前路径</span></span><br><span class="line">snap</span><br><span class="line">peko</span><br><span class="line">pekosh</span><br><span class="line">R</span><br><span class="line">.ssh</span><br></pre></td></tr></table></figure>

<h1 id="脚本的结构-1"><a href="#脚本的结构-1" class="headerlink" title="脚本的结构"></a>脚本的结构</h1><p>在 <code>bash</code> 中, 脚本就是命令和控制逻辑的组合, 我们先看一个普通脚本的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is information provided by mysystem.sh.  Program starts now."</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"Hello, <span class="variable">$USER</span>\n\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"Today's date is `date` , this is week `date +"</span>%V<span class="string">"` .\n\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"These users are currently connected:"</span></span><br><span class="line">w | cut -d <span class="string">" "</span> -f 1 - | grep -v USER | sort -u</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"This is `uname -s` running on a `uname -m` processor.\n\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is the uptime information:"</span></span><br><span class="line">uptime</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"That's all folks!"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>#!/bin/bash</code> 是 <code>Shebang</code> , 用于指定这个脚本的解释器。</li>
<li><code>/usr/bin/clear</code> 是一个外部命令，用于清除当前 <code>shell</code> 中的输出信息。</li>
<li><code>echo</code> 和 <code>printf</code> 都是 <code>bash</code> 的内置命令，不同的是 <code>echo</code> 始终以 <code>0</code> 状态码退出（退出状态永远是成功），并且仅在标准输出上打印参数，然后打印行尾字符，而 <code>printf</code> 允许定义格式字符串，并在失败时给出非零的退出状态代码。</li>
<li><code>USER</code> 是一个变量，用于存储当前用户的名字，需要使用取出变量的值。</li>
</ul>
<p>脚本有两种执行方式:</p>
<ul>
<li><code>source</code> 或 <code>.</code> : 这种方式是在当前 <code>shell</code> 中执行脚本, 等价于用 <code>{}</code> 包裹的代码块, 但要注意这种执行方法可能会污染当前 <code>shell</code> 中的变量.</li>
<li><code>./脚本名</code> 或 <code>bash 脚本名</code> : 这种方式本质上是执行外部变量 <code>bash</code> 并将脚本名作为参数传递给命令, 这种方法启动的脚本会运行在 <code>child shell</code> 中, 不可以访问父 <code>shell</code> 的全局变量, 只能访问环境变量. 需要注意的是使用 <code>./脚本名</code> 方法执行脚本需要在脚本第一行配置 <code>Shebang</code> .</li>
</ul>
<p>我们再来看一个初始化脚本 <code>upon-sound</code> 的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span>  <span class="comment"># 脚本的控制逻辑，根据输入选择要执行的分支</span></span><br><span class="line"><span class="string">'start'</span>)  <span class="comment"># 服务启动时执行</span></span><br><span class="line">  cat /usr/share/audio/at_your_service.au &gt; /dev/audio</span><br><span class="line">  ;;</span><br><span class="line"><span class="string">'stop'</span>)  <span class="comment"># 服务停止时执行</span></span><br><span class="line">  cat /usr/share/audio/oh_no_not_again.au &gt; /dev/audio</span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>初始化脚本（启动脚本）存储在 <code>/etc/rc.d/init.d</code> 或 <code>/etc/init.d</code> 目录下，用于启动系统服务，例如：系统日志服务，电源管理服务，名称和邮件服务。 <code>PID=1</code> 的初始化进程 <code>init</code> 读取其配置文件，并决定在每个运行级别中启动或停止哪些服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; mv upon-sound /etc/init.d/upon-sound</span><br><span class="line">&gt; ln -s /etc/init.d/upon-sound /etc/rc3.d/S99upon-sound  <span class="comment"># 运行级别为3 启动时调用 start</span></span><br><span class="line">&gt; ln -s /etc/init.d/upon-soudecanshund /etc/rc0.d/K01upon-sound  <span class="comment"># 运行级别为0 关机时调用 stop</span></span><br></pre></td></tr></table></figure>

<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul>
<li><a href="https://catonmat.net/bash-functions" target="_blank" rel="noopener">Something you didn’t know about functions in bash</a></li>
<li><a href="https://linjian.org/blog/tech/linux/shell/bash-add-builtin" target="_blank" rel="noopener">Adding builtins for bash</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A7%8D%E7%B1%BB/" data-id="ck8oiuufq000ae6ax0ugk3v25" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/命令的执行方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/">bash/mechanism/命令的执行方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="fork-exec-模式"><a href="#fork-exec-模式" class="headerlink" title="fork-exec 模式"></a><code>fork-exec</code> 模式</h2><p>在 <code>Linux</code> 系统中，所有的进程（包括 <code>PID=1</code> 的 <code>init</code> 进程，但不包括 <code>PID=0</code> 的调度进程）的创建都遵循 <code>fork-exec</code> 模式。</p>
<ul>
<li><code>fork</code> ：作为进程创建的第一阶段，其作用为将父进程的<strong>地址空间</strong>（代码段[只拷贝引用]、数据段、堆、栈）全部拷贝给子进程，父进程调用 <code>fork</code> 之后由内核进行操作，创建完之后给父进程返回创建好的子进程的 <code>PID</code> ，给子进程返回 <code>0</code> （子进程的 <code>task_struct</code> 中会记录父进程的 <code>PID</code> ）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父进程与子进程共享代码段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  // fork()的原型在这个头文件中</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span> )  <span class="comment">// 返回-1，说明fork失败  </span></span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"fork"</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  <span class="comment">// 返回子进程pid，说明是父进程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent PID = %d\n"</span>, getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)  <span class="comment">// 返回0，说明是子进程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child PID = %d, PPID = %d\n"</span>, getpid(), getppid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[danger]<strong>危险</strong>：在 <code>Linux</code> 系统中，父进程执行 <code>fork</code> 只会复制<strong>发起调用的线程</strong>的信息，其他线程在子进程中会立即停止并消失，并且默认不会为这些线程调用清理函数以及针对线程局部存储变量的析构函数（可能引发死锁），关于这部分的详细内容会在第二章进行说明。</p>
</blockquote>
<ul>
<li><code>exec</code> ：作为进程创建过程中可选的第二阶段，如果我们需要在子进程空间里面运行全新的代码，可以使用 <code>exec</code> 函数族将新程序的代码段<strong>加载</strong>到子进程的地址空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)  <span class="comment">//返回0，说明是子进程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>  *argv[] = &#123;<span class="string">"ls"</span>, <span class="string">"-al"</span>, <span class="string">"/etc/passwd"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>  *envp[] = &#123;<span class="string">"PATH=/bin"</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 只有execve是系统调用，其他exec函数都是它的包装</span></span><br><span class="line">    execve(<span class="string">"/bin/ls"</span>, argv, envp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[info]<strong>提示</strong>：由于写时拷贝（copy-on-write）技术的引入，在调用 <code>fork</code> 时，内核并不会立即拷贝整个父进程的地址空间给子进程（只读共享），而是在需要写入时才会拷贝，因此在 <code>fork</code> 之后立即调用 <code>exec</code> 就可以显著提升进程创建的效率 。</p>
</blockquote>
<p>首先说一下fork和vfork的差别：fork  是 创建一个子进程，并把父进程的内存数据copy到子进程中。vfork是 创建一个子进程，并和父进程的内存数据share一起用。这两个的差别是，一个是copy，一个是share。你 man vfork 一下，你可以看到，vfork是这样的工作的，1）保证子进程先执行。2）当子进程调用exit()或exec()后，父进程往下执行。那么，为什么要干出一个vfork这个玩意？  原因是这样的—— 起初只有fork，但是很多程序在fork一个子进程后就exec一个外部程序，于是fork需要copy父进程的数据这个动作就变得毫无意了，而且还很重，所以，搞出了个父子进程共享的vfork。所以，vfork本就是为了exec而生。</p>
<p>就是fork后来采用的优化技术，这样，对于fork后并不是马上拷贝内存，而是只有你在需要改变的时候，才会从父进程中拷贝到子进程中，这样fork后立马执行exec的成本就非常小了。而vfork因为共享内存所以比较危险，所以，Linux的Man Page中并不鼓励使用vfork()</p>
<p>实际存在fork, clone, vfork 三个系统调用。fork是完全复制，clone则是有选择的复制，vfork则完全使用父进程的资源。</p>
<p>main函数并不是开始，之前有个函数(至少gcc是这样，别的不懂)，姑且叫start，start函数里初始化一些我也不知道是什么的貌似并没有什么卵用的东西，然后调用main，return是函数的返回，main的return就返回到start，exit是退出进程，善后，然后自杀，参数是返回到调用进程的，比如shell，</p>
<p>每个C程序的入口点_start处的代码用伪代码表示为<br>_start:<br>call __libc_init_first // 一些初始化<br>call _init<br>call atexit<br>call main<br>call _exit<br>从伪代码就看出来了，每个C程序都要在执行一些初始化函数后对main调用，若main末尾为return语句，那么控制返回，最终会call _exit，把控制返回系统。若省略return，那么也将会call _exit。如果代码中有exit函数，那么会先执行atexit注册的函数，进而执行_exit()把控制还给操作系统。总之，这些情况下，当main返回，控制会传给系统</p>
<blockquote>
<p>[success]<strong>技巧</strong>：在 <code>Linux 2.6.32</code> 版本之后提供了配置文件 <code>/proc/sys/kernel/sched_child_runs_first</code> ，将该文件的值置为<strong>非零</strong>可以让内核在创建完进程后会将子进程放在就绪态队列前端，避免父进程先写入数据导致无意义拷贝（但这并不能完全保证子进程优先执行）。</p>
</blockquote>
<h2 id="库函数-system"><a href="#库函数-system" class="headerlink" title="库函数 system"></a>库函数 <code>system</code></h2><p>作为对 <code>fork</code> 和 <code>execl</code> 系统调用的封装， <code>system</code> 这个库函数是的代码执行部分等价于:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, command, (<span class="keyword">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h2 id="实现简单的-shell"><a href="#实现简单的-shell" class="headerlink" title="实现简单的 shell"></a>实现简单的 shell</h2><h1 id="命令处理流程"><a href="#命令处理流程" class="headerlink" title="命令处理流程"></a>命令处理流程</h1><h2 id="命令预处理"><a href="#命令预处理" class="headerlink" title="命令预处理"></a>命令预处理</h2><p>为了避免创建无意义进程， <code>bash</code> 在执行命令前会按照以下步骤对输入的命令进行检查：</p>
<ul>
<li>检查命令是否包含 <code>/</code> ，如果不包含就检查当前 <code>shell</code> 的函数列表, 否则将命令视为外部命令执行。</li>
<li>检查内置命令列表。</li>
<li>检查 <code>PATH</code> 变量中的所有路径， <code>bash</code> 使用哈希表（内存中的数据存储区）记住可执行文件的完整路径名，因此可以避免多次重复的全局搜索。</li>
<li>如果还是找不到就返回 <code>127</code> 状态码。</li>
<li>如果命令不是以异步方式启动的，则 <code>shell</code> 将等待命令完成并获取其退出状态。</li>
</ul>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h2 id="命令执行环境"><a href="#命令执行环境" class="headerlink" title="命令执行环境"></a>命令执行环境</h2><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/23695915/does-the-linux-scheduler-prefer-to-run-child-process-after-fork" target="_blank" rel="noopener">Does the Linux scheduler prefer to run child process after fork()?</a></li>
<li><a href="https://stackoverflow.com/questions/17391201/does-proc-sys-kernel-sched-child-runs-first-work/17393268%2317393268" target="_blank" rel="noopener">Does /proc/sys/kernel/sched_child_runs_first work?</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/" data-id="ck8oiuufk0002e6axf8q2amgg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/自动补全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/">bash/mechanism/自动补全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="自动补全原理"><a href="#自动补全原理" class="headerlink" title="自动补全原理"></a>自动补全原理</h1><p>使用 <code>TAB</code> 键可以根据已输入的字符自动补全<strong>路径名</strong>、<strong>文件名</strong>和<strong>可执行程序</strong>，自动补全依赖于 <code>bash-completion</code> 在 <code>/etc/bash_completion.d/</code> 路径下创建的自动补全脚本。</p>
<h2 id="实现简单的参数自动补全"><a href="#实现简单的参数自动补全" class="headerlink" title="实现简单的参数自动补全"></a>实现简单的参数自动补全</h2><p>实现自动补全需要使用内置命令 <code>compgen</code> 和 <code>complete</code> 以及 <code>bash</code> 提供的内置的补全变量，我们先看下面这个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment"># 脚本1： vtb.bash</span></span><br><span class="line">_vtb()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> cur=<span class="variable">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span></span><br><span class="line">    COMPREPLY=( $(compgen -W <span class="string">"mea aqua alice"</span> -- <span class="variable">$cur</span>) )</span><br><span class="line">&#125;</span><br><span class="line">complete -F _vtb vtb</span><br></pre></td></tr></table></figure>

<p>赋予执行权限并测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> chmod +x vtb.bash</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">source</span> vtb.bash</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vtb &lt;TAB&gt; &lt;TAB&gt;</span></span><br><span class="line">alice  aqua   mea</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vtb a &lt;TAB&gt; &lt;TAB&gt;</span></span><br><span class="line">alice  aqua</span><br></pre></td></tr></table></figure>

<p>现在 <code>vtb</code> 这个命令已经具有了参数补全的功能，不难发现其给出的选项来自于 <code>_vtb</code> 函数中的 <code>COMPREPLY</code> 数组。</p>
<h2 id="内置补全变量表"><a href="#内置补全变量表" class="headerlink" title="内置补全变量表"></a>内置补全变量表</h2><table>
<thead>
<tr>
<th>变量名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>COMP_WORDS</td>
<td>类型为数组，存放当前命令行中输入的所有单词</td>
</tr>
<tr>
<td>COMP_CWORD</td>
<td>类型为整数，当前光标所在位置的单词在COMP_WORDS中的索引</td>
</tr>
<tr>
<td>COMPREPLY</td>
<td>类型为数组，候选的补全结果</td>
</tr>
<tr>
<td>COMP_WORDBREAKS</td>
<td>类型为字符串，表示单词之间的分隔符</td>
</tr>
<tr>
<td>COMP_LINE</td>
<td>类型为字符串，表示当前的命令行输入字符</td>
</tr>
<tr>
<td>COMP_POINT</td>
<td>类型为整数，表示光标在当前命令行的哪个位置</td>
</tr>
</tbody></table>
<h2 id="理解-compgen-W"><a href="#理解-compgen-W" class="headerlink" title="理解 compgen -W"></a>理解 <code>compgen -W</code></h2><p>在 <code>脚本1</code> 的 <code>_vtb</code> 函数中，我们首先定义了 <code>cur</code> 变量用于获取<strong>当前光标所在位置的单词</strong>，将其作为参数传递给 <code>compgen -W</code> 命令。该命令接受两个参数，定义与使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># compgen -W &lt;word_list&gt; &lt;comp_word&gt;</span></span><br><span class="line">&gt; compgen -W <span class="string">"aqua alice mea"</span> -- a  <span class="comment"># 省略‘--’则不会输出多行</span></span><br><span class="line">aqua</span><br><span class="line">alice</span><br></pre></td></tr></table></figure>

<p><code>compgen</code> 命令的作用是完成候选词的<strong>筛选</strong>， <code>-W</code> 模式代表从 <code>&lt;word_list&gt;</code> 中获得候选词，然后通过 <code>&lt;comp_word&gt;</code> 参数对候选词进行筛选，最后我们将筛选得到的结果存入 <code>COMPREPLY</code> 数组中。</p>
<h2 id="理解-complete-F"><a href="#理解-complete-F" class="headerlink" title="理解 complete -F"></a>理解 <code>complete -F</code></h2><p>我们在 <code>脚本1</code> 中使用了 <code>complete</code> 命令的 <code>-F</code> 模式让 <code>vtb</code> 命令能够获取 <code>_vtb</code> 函数中的候选补全结果 <code>COMPREPLY</code> ，其本质就是完成候选词的<strong>绑定</strong>。我们先以简单的 <code>-W</code> 模式为例进行讲解，其定义与使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># complete -W &lt;word_list&gt; &lt;comp_cmd&gt;</span></span><br><span class="line">&gt; complete -W <span class="string">"aa ab cd"</span> test_comp</span><br><span class="line">&gt; test_comp &lt;TAB&gt; &lt;TAB&gt;</span><br><span class="line">aa    ab    <span class="built_in">cd</span></span><br><span class="line">&gt; test_comp a &lt;TAB&gt; &lt;TAB&gt;</span><br><span class="line">aa    ab</span><br></pre></td></tr></table></figure>

<p><code>complete</code> 命令可以给 <code>&lt;comp_cmd&gt;</code> 绑定候选词列表，根据不同的命令模式（ <code>-F -W -C -G</code> ）会有不同的构建候选词列表的方式。 <code>-W</code> 模式通过字符串构建候选词列表，而 <code>-F</code> 模式需要使用 <code>COMPREPLY</code> 构造候选词列表，其定义与使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complete -F &lt;func_name&gt; &lt;comp_cmd&gt;     <span class="comment"># 绑定候选词列表</span></span><br><span class="line">&lt;comp_cmd&gt; &lt;comp_word&gt; &lt;TAB&gt; &lt;TAB&gt;     <span class="comment"># 筛选候选词列表</span></span><br></pre></td></tr></table></figure>

<p>该命令可以实现 <code>&lt;func_name&gt;</code> 与 <code>&lt;comp_cmd&gt;</code> 的绑定， <code>&lt;func_name&gt;</code> 函数中必须通过 <code>COMPREPLY</code> 构造候选词列表，而是否使用 <code>compgen</code> 或其他方式进行候选词筛选取决于业务逻辑。相比于其他模式， <code>-F</code> 模式能够提供更灵活的自动补全策略，以 <code>脚本1</code> 为例，我们通过组合使用 <code>compgen</code> 、 <code>complete</code> 和内置补全变量实现了类似 <code>-W</code> 模式的功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/" data-id="ck8oiuufl0003e6ax9r1a3kcu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/子shell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E5%AD%90shell/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E5%AD%90shell/">bash/mechanism/子shell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <code>bash</code> 中的子 <code>shell</code> 可以分为以下两类：</p>
<ul>
<li><code>subshell</code> ：通过进程替换、 <code>(LIST)</code> 、 <code>|</code> 或 <code>&amp;</code> 创建的子 <code>shell</code> 。因为这种子 <code>shell</code> 在创建时只使用了 <code>fork</code> 函数，导致其可以继承父 <code>shell</code> 的全部变量（局部变量也会被继承，甚至包括<code></code>bash<code>中的子</code>shell<code>可以分为以下两类：和</code>$PID` ）、别名和函数。</li>
<li><code>child shell</code> ：我们调用 <code>bash</code> 命令生成交互式 <code>shell</code> 或执行脚本都会得到这种子 <code>shell</code> 。这种子 <code>shell</code> 在创建时会通过 <code>fork</code> 和 <code>exec</code> 函数将其代码、数据、堆栈替换为全新的 <code>bash</code> 进程，因此只会继承父 <code>shell</code> 传递来的全局变量。</li>
</ul>
<p>shell启动的shell子进程称为子shell。直接以文件名运行可执行文件时，bash并不知道它调用的一个可执行是二进制文件还是脚本，只是在exec过程中交给系统内核处理。对于shell脚本，通常以“#![shell可执行文件名]”开头，“#!”是一种magic number。当内核通过magic number断定执行的是脚本时，就会调用一个新的指定的shell的实例来解释执行脚本，这个实例就是子shell。父子shell是两个进程，所以各自的变量是独立的。除非父shell将自己的变量导出到环境中，否则子shell无法获得父shell中定义的变量。</p>
<p>bash通过变量SHLVL记录自己是进程调用栈中哪一层的shell，即bash被嵌套的深度。bash启动时，调用variables.c中的initialize_shell_level()设置SHLVL。系统login之后启动的bash的SHLVL为1，每层shell启动的子shell的SHLVL在其环境中读到的SHLVL基础上加1。</p>
<p>使用source命令（“.”命令）执行脚本时，不开启子shell。bash内部的实现是将脚本文件内容读入一个缓冲区，然后执行语法分析，因此效果与直接从键盘输入脚本内容相同。</p>
<h1 id="创建-subshell"><a href="#创建-subshell" class="headerlink" title="创建 subshell"></a>创建 subshell</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 subshell 的方法</span></span><br><span class="line">&gt; <span class="built_in">echo</span> `<span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>` </span><br><span class="line">1  <span class="comment"># 命令替换会创建 subshell</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span> &amp;</span><br><span class="line">1  <span class="comment"># 后台执行会创建 subshell</span></span><br><span class="line">&gt; (<span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>)</span><br><span class="line">1  <span class="comment"># 一对小括号会创建 subshell</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">function</span> f1()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span> &gt;&amp;2</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; f1</span><br><span class="line">0</span><br><span class="line">&gt; f1 | f1 | f1</span><br><span class="line">1  <span class="comment"># 三个独立的 subshell</span></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道陷阱</span></span><br><span class="line">&gt; a=10</span><br><span class="line">&gt; a=5 | <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">10  <span class="comment"># 左右两侧都在各自创建的 subshell 中执行 互不影响</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">10  <span class="comment"># 在 subshell 中修改变量不会影响父 shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 证明确实创建了子 shell</span></span><br><span class="line">&gt; pstree -p $; <span class="built_in">echo</span> $ <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>;</span><br><span class="line">bash(2695)───pstree(2702)  </span><br><span class="line">2695 1 0</span><br><span class="line">&gt; (pstree -p $; <span class="built_in">echo</span> $ <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>;)</span><br><span class="line">bash(2695)───bash(2714)───pstree(2715)</span><br><span class="line">2695 1 1  <span class="comment"># $也被继承了，但注意其值是 invorking shell 的 PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LIST 必须为多条命令才会创建子 shell</span></span><br><span class="line">&gt; pidof bash; (pidof bash;)</span><br><span class="line">2695</span><br><span class="line">2695</span><br><span class="line">&gt; pidof bash; (<span class="built_in">echo</span>&gt;/dev/null;pidof bash;)</span><br><span class="line">2695  </span><br><span class="line">3163 2695</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有 subshell 可以继承局部变量</span></span><br><span class="line">&gt; <span class="built_in">unset</span> a; a=1</span><br><span class="line">&gt; (<span class="built_in">echo</span> <span class="string">"a is <span class="variable">$a</span> in the subshell"</span>)</span><br><span class="line">a is 1 <span class="keyword">in</span> the subshell  <span class="comment"># 仅 fork 完全拷贝</span></span><br><span class="line">&gt; bash -c <span class="string">'echo "a is $a in the child shell"'</span></span><br><span class="line">a is  <span class="keyword">in</span> the child shell  <span class="comment"># fork 并 exec 导致信息被覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看嵌套层级</span></span><br><span class="line">&gt; (<span class="built_in">echo</span> <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>;(<span class="built_in">echo</span> <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>;(<span class="built_in">echo</span> <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>)))</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">&gt; bash</span><br><span class="line">&gt; (<span class="built_in">echo</span> <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>;(<span class="built_in">echo</span> <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>;(<span class="built_in">echo</span> <span class="variable">$SHLVL</span> <span class="variable">$BASH_SUBSHELL</span>)))</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>

<p><code>SHLVL</code> 变量用于记录 <code>shell</code> 的嵌套层级， <code>BASH_SUBSHELL</code> 用于记录 <code>subshell</code> 的嵌套层级。</p>
<h1 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h1><p>使用 <code>bash</code> 命令（相当于在当前 <code>shell</code> 中执行了外部命令）执行 <code>shell</code> 脚本时会创建 <code>child shell</code> ；使用 <code>source</code> 、 <code>.</code> 或 <code>exec</code> 则会直接在当前 <code>shell</code> 中执行脚本，不会额外创建 <code>child shell</code> （不包括脚本中的命令可能会自行创建的子 <code>shell</code> ）。使用 <code>bash</code> 命令得到的 <code>child shell</code> 每次从脚本读取一行，每行命令都像直接来自键盘一样被读取、解释和执行，父 <code>shell</code> 在此过程中将通过 <code>wait</code> 系统调用等待其子进程完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash my.sh  <span class="comment"># 会创建子 shell</span></span><br><span class="line">./my.sh  <span class="comment"># 会创建子 shell</span></span><br><span class="line">. my.sh  <span class="comment"># 不会创建子 shell，因为是内置命令</span></span><br><span class="line"><span class="built_in">source</span> my.sh  <span class="comment"># 不会创建子 shell，因为 `source` 是 `.` 的别称</span></span><br></pre></td></tr></table></figure>

<p>简单总结一下子进程和子 <code>shell</code> ：</p>
<ul>
<li>执行内置命令和 <code>shell</code> 脚本中的函数时，连子进程都不会创建，自然也不会创建子 <code>shell</code> 。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkfifo a</span><br><span class="line">&gt; <span class="function"><span class="title">fc1</span></span>()&#123; a&lt;a; &#125;  <span class="comment"># 定义一个 shell 脚本函数</span></span><br><span class="line">&gt; <span class="built_in">echo</span> a&lt;a &amp;</span><br><span class="line">&gt; pstree -pa $</span><br><span class="line">bash,6080</span><br><span class="line">  ├─bash,11092  <span class="comment"># 这个 subshell 是 &amp; 创建的</span></span><br><span class="line">  └─pstree,11095 -pa 6080</span><br><span class="line"><span class="comment"># 内置命令 echo 直接在 11092 中执行，甚至都没有建立子进程</span></span><br><span class="line"><span class="comment"># 可以另开一个终端然后 pstree -pa &lt;上面那个bash的pid&gt; 进行验证</span></span><br><span class="line">&gt; fc1 &amp;</span><br><span class="line">&gt; pstree -pa 6080  <span class="comment"># 在另一个终端中输入</span></span><br><span class="line">bash,6080  <span class="comment"># 只显示这个 没有创建任何子进程</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行外部命令时会使用 <code>fork-exec</code> 模式创建子进程，如果外部命令是 <code>shell</code> 类型则会创建 <code>child shell</code> 。</li>
<li>使用 <code>source</code> 、 <code>.</code> 、 <code>exec</code> 执行脚本以及用 <code>{ LIST }</code> （注意是大括号）包裹命令列表相当于在当前 <code>shell</code> 中逐行输入命令，要注意使用 <code>exec</code> 执行完脚本后会退出 <code>shell</code> 。</li>
<li>使用 <code>bash xxx.sh</code> 或 <code>./xxx.sh</code> 运行脚本会创建 <code>child shell</code> 。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat test.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sleep 30;</span><br><span class="line"></span><br><span class="line">&gt; bash test.sh  <span class="comment"># 回车之后 ctrl+z</span></span><br><span class="line">&gt; pstree -pa $</span><br><span class="line">bash,6080</span><br><span class="line">  ├─bash,12602 test.sh  <span class="comment"># 自动创建的 child shell</span></span><br><span class="line">  │   └─sleep,12603 30  <span class="comment"># 逐行解释执行的命令</span></span><br><span class="line">  └─pstree,12606 -pa 6080</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>( LIST )</code> 执行命令列表会自动创建 <code>subshell</code> 。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> (<span class="built_in">echo</span>;sleep 30;)  <span class="comment"># 回车之后按下 ctrl + z</span></span></span><br><span class="line">                </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> pstree -pa $</span></span><br><span class="line">bash,6080  # 敲命令的 invoking shell</span><br><span class="line">  ├─bash,9780  # 自动创建的 subshell，可与父 shell 共享局部变量</span><br><span class="line">  │   └─sleep,9781 30  # 执行外部命令创建的 child process</span><br><span class="line">  └─pstree,9782 -pa 6080</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">fg</span> 1  <span class="comment"># 可以等待完成 也可以直接 ctrl+c</span></span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E5%AD%90shell/" data-id="ck8oiuufl0004e6ax4e5cafhx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/初始化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E5%88%9D%E5%A7%8B%E5%8C%96/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E5%88%9D%E5%A7%8B%E5%8C%96/">bash/mechanism/初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Bash-初始化文件"><a href="#Bash-初始化文件" class="headerlink" title="Bash 初始化文件"></a>Bash 初始化文件</h1><h2 id="交互式-login-shell"><a href="#交互式-login-shell" class="headerlink" title="交互式 login shell"></a>交互式 login shell</h2><p>在下列情况下，我们可以获得一个 <code>login shell</code> ：</p>
<ul>
<li>登录系统时获得的顶层 <code>shell</code> ，无论是通过本地终端登录，还是通过网络 <code>ssh</code> 登录。这种情况下获得的 <code>login shell</code> 是一个交互式 <code>shell</code> 。</li>
<li>在终端下使用 <code>--login</code> 选项调用 <code>bash</code> ，可以获得一个交互式 <code>login shell</code> 。</li>
<li>在脚本中使用 <code>--login</code> 选项调用 <code>bash</code> （例如： <code>#!/bin/bash --login</code> ）可以得到一个非交互式的 <code>login shell</code> 。</li>
<li>使用 <code>su -</code> 切换到指定用户时，获得此用户的 <code>login shell</code> 。如果不使用 <code>-</code> ，则获得 <code>non-login shell</code> 。</li>
</ul>
<p><code>login shell</code> 启动时首先读取 <code>/etc/profile</code> 系统全局配置，然后依次查找 <code>~/.bash_profile</code> 、 <code>~/.bash_login</code> 、 <code>~/.profile</code> 三个配置文件，并且读取<strong>首个</strong>找到的并且可读的文件。 <code>login shell</code> 退出时读取并执行 <code>~/.bash_logout</code> 中的命令。 如果配置文件存在但不可读，则会显示错误消息；如果文件不存在， <code>bash</code> 将自动搜索下一个文件。</p>
<blockquote>
<p>[!1info]<br>默认的 <code>/etc/profile</code> 会定义 <code>PATH</code> 、 <code>USER</code> 、 <code>MAIL</code> 、 <code>HOSTNAME</code> 、 <code>HISTSIZE</code> 等全局环境变量，还会自动导入 <code>/etc/bash.bashrc</code> 文件（包含系统级 <code>shell</code> 函数和别名），以及 <code>/etc/profile.d</code> 路径下被用于针对特定程序进行初始化的所有 <code>*.sh</code> 文件。</p>
</blockquote>
<h2 id="交互式-non-login-shell"><a href="#交互式-non-login-shell" class="headerlink" title="交互式 non-login shell"></a>交互式 non-login shell</h2><p>非登录 <code>shell</code> 意味着在启动时不必通过系统身份验证。 <code>GUI</code> 中用户打开的终端默认为非登录 <code>shell</code> ，可以通过 <code>logout</code> 命令判断：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Ubuntu GUI桌面打开一个终端</span></span><br><span class="line">&gt; <span class="built_in">logout</span></span><br><span class="line">bash: <span class="built_in">logout</span>: not login shell: use `<span class="built_in">exit</span><span class="string">'</span></span><br><span class="line"><span class="string">&gt; bash --login</span></span><br><span class="line"><span class="string">&gt; logout  # 正常登出 什么也不会输出</span></span><br></pre></td></tr></table></figure>

<p>非登录 <code>shell</code> 在初始化时仅读取 <code>~/.bashrc</code> 资源文件。</p>
<blockquote>
<p>[!1INFO]<br><code>~/.bashrc</code> 文件会自动被 <code>~/.bash_profile</code> 或 <code>~/.profile</code> 加载，因此为了保证 <code>login shell</code> 和交互式 <code>non-login shell</code> 得到相同的配置，一般将环境变量定义在 <code>~/.bashrc</code> 文件中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"export sflag=\"login shell will see this message\""</span> &gt;&gt; ~/.profile    </span><br><span class="line">&gt; bash  </span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$sflag</span>  </span><br><span class="line">                    <span class="comment"># 找不到这个变量 会打印一个空行</span></span><br><span class="line">&gt; <span class="built_in">exit</span>  </span><br><span class="line">&gt; bash --login  </span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$sflag</span>  </span><br><span class="line">login shell will see this message  </span><br><span class="line">&gt; <span class="built_in">logout</span></span><br></pre></td></tr></table></figure>

<h2 id="非交互式-shell"><a href="#非交互式-shell" class="headerlink" title="非交互式 shell"></a>非交互式 shell</h2><p>通过 <code>bash</code> 命令执行脚本时会以非交互（ <code>non-interactively</code> ）的方式启动 <code>shell</code> ，这保证了在脚本执行过程中不会被用户干扰。在非交互式脚本启动时，仅会加载 <code>BASH_ENV</code> 变量指向的文件。</p>
<blockquote>
<p>[!1WARN]<br>由于 <code>PATH</code> 变量默认不会被非交互式 <code>shell</code> 加载，因此变量 <code>BASH_ENV</code> 的值应该为绝对路径。</p>
</blockquote>
<p>通过特殊变量 <code>-</code> 可以查看当前shell的模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> $-</span><br><span class="line">himBHs  <span class="comment"># 带有'i'就是交互式shell</span></span><br></pre></td></tr></table></figure>

<p>另一个简单的方式是检查当前 <code>shell</code> 中是否存在提示符环境变量 <code>PS1</code> .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$PS1</span>"</span> ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"非交互式"</span>;<span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">"交互式"</span>;<span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="兼容模式"><a href="#兼容模式" class="headerlink" title="兼容模式"></a>兼容模式</h2><p>如果使用命令 <code>sh</code> 调用 <code>bash</code> ，则为了保证兼容性会按照 <code>sh</code> 的方式对 <code>bash</code> 进行初始化。作为 <code>login shell</code> 启动时， <code>bash</code> 依次读取 <code>/etc/profile</code> 和 <code>~/.profile</code> 配置文件。作为 <code>non-login shell</code> 启动时， <code>bash</code> 仅会读取环境变量 <code>ENV</code> 指向的文件。 </p>
<h2 id="POSIX-模式"><a href="#POSIX-模式" class="headerlink" title="POSIX 模式"></a>POSIX 模式</h2><p>当通过以下方式启动 <code>bash</code> 时：</p>
<ul>
<li>设置 <code>set -o posix</code> 或 <code>export POSIXLY_CORRECT=1</code> </li>
<li><code>bash --posix</code> </li>
</ul>
<p><code>bash</code> 会尽可能按照 <code>POSIX</code> 标准进行初始化，仅会读取环境变量 <code>ENV</code> 指向的文件。</p>
<h2 id="远程启动脚本"><a href="#远程启动脚本" class="headerlink" title="远程启动脚本"></a>远程启动脚本</h2><p>使用 <code>rshd</code> 远程启动脚本时仅会加载 <code>~/.bashrc</code> 文件，但要注意的是尽量不要使用 <code>rlogin, telnet, rsh, rcp</code> 等远程命令，因为这些命令会传输未加密的明文信息。如果有远程访问需求尽量使用<a href="http://www.openssh.org/" target="_blank" rel="noopener">SSH</a>。</p>
<h2 id="UID-与-EUID-不匹配"><a href="#UID-与-EUID-不匹配" class="headerlink" title="UID 与 EUID 不匹配"></a>UID 与 EUID 不匹配</h2><p>如果我们给 <code>bash</code> 设置 <code>set-user-id</code> 标志，那么由于其默认所有者为 <code>root</code> ，当其他非 <code>root</code> 用户运行 <code>bash</code> 时，该进程的 <code>UID</code> 将不等于 <code>EUID</code> ，这种情况下为了保证安全性， <code>bash</code> 在初始化阶段不会加载任何文件。</p>
<blockquote>
<p>[!1INFO]<br><code>Linux</code> 内核会为每个进程维护 <code>task_struct</code> 用于记录进程运行时所需要的信息, 其中 <code>UID</code> （真实用户ID）用于记录创建进程的用户的 <code>UID</code> ， <code>EUID</code> （有效用户ID）用于判断当前进程对文件的访问级别，一般情况下 <code>UID = EUID</code> 。如果可执行文件的 <code>set-user-id: SUID</code> 位有效（例如： <code>/usr/bin/passwd</code> 的权限为 <code>-rwsr-xr-x</code> ，用户级别的 <code>x</code> 被替换为 <code>s</code> ），表示当该文件被执行时，进程具有文件所有者的权限而不是创建者的权限, 这时 <code>EUID</code> 的值为文件所有者的 <code>UID</code> , 而不是进程创建者的 <code>UID</code> .</p>
</blockquote>
<h2 id="受限制的-shell"><a href="#受限制的-shell" class="headerlink" title="受限制的 shell"></a>受限制的 shell</h2><p>通过 <code>rbash</code> 或 <code>bash --restricted</code> 或 <code>bash -r</code> 启动时会生成功能受限制的shell，具体表现为：</p>
<ul>
<li>不能使用 <code>cd</code> 命令并且命令中不能包含 <code>/</code> </li>
<li>不能更改 <code>SHELL</code> 、 <code>PATH</code> 、 <code>ENV</code> 和 <code>BASH_ENV</code> 环境变量</li>
<li><code>source</code> 命令的参数也不能包含带有 <code>/</code> 的文件</li>
<li><code>hash –p &lt;path&gt; &lt;name&gt;</code> 用于给路径起别名的命令的参数中也不能包含 <code>/</code> </li>
<li>初始化时不会导入文件中的函数并且会忽略 <code>SHELLOPTS</code> </li>
<li>不能使用重定向</li>
<li>不能使用 <code>exec</code> 命令</li>
<li>不能使用 <code>enable -f/-d</code> 增加删除命令</li>
<li>不能使用 <code>command -p</code> 指定运行命令需要的路径</li>
<li>不能主动关闭限制模式</li>
</ul>
<p>这个功能<strong>理论上</strong>可以让用户在指定的文件夹内执行指定的文件来完成有限的功能，但是如果环境变量设置不当会导致用户很轻松地就能解除限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; rbash</span><br><span class="line">&gt; <span class="built_in">cd</span> /etc</span><br><span class="line">rbash: <span class="built_in">cd</span>: restricted</span><br><span class="line">&gt; bash</span><br><span class="line">&gt; <span class="built_in">cd</span> /etc  <span class="comment"># 可以成功执行，因为这个时候我们在bash环境中，没有任何限制</span></span><br></pre></td></tr></table></figure>

<p>一种有效的做法是给新建的用户的能执行的命令作出限制，例如我们可以新建一个只能执行 <code>ftp</code> 命令的 <code>ruser</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; useradd -s /bin/rbash ruser  <span class="comment"># 设置用户登录时提供的shell</span></span><br><span class="line">&gt; chown -R root:ruser /home/ruser/.bashrc /home/ruser/.bash_profile</span><br><span class="line"><span class="comment"># 设置root为拥有者，ruser组为组拥有者（新建的ruser默认输入ruser组）</span></span><br><span class="line">&gt; chmod 640 /home/ruser/.bashrc /home/ruser/.bash_profile</span><br><span class="line"><span class="comment"># root可以读写，ruser组里的用户只读，其他用户什么也不能干</span></span><br><span class="line">&gt; mkdir /home/ruser/bin  <span class="comment"># 存储用户的可执行文件或链接</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"export PATH=/home/ruser/bin"</span> &gt;&gt; /home/ruser/.bash_profile</span><br><span class="line">&gt; ln -s /user/bin/ftp /home/ruser/bin/ftp</span><br></pre></td></tr></table></figure>

<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul>
<li><a href="http://www.linuxfromscratch.org/blfs/view/6.3/postlfs/profile.html" target="_blank" rel="noopener">The Bash Shell Startup Files</a></li>
<li><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_01.html" target="_blank" rel="noopener">Shell initialization files</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E5%88%9D%E5%A7%8B%E5%8C%96/" data-id="ck8oiuufk0001e6axa6keco2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/作业控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/">bash/mechanism/作业控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h1><p>在 <code>shell</code> 中通过 <code>command &amp;</code> 可以创建后台作业, 通过 <code>jobs -l</code> 命令可以查看当前 <code>shell</code> 中维护的作业列表, 包括他们的作业号, 进程号, 运行状态. 其中作业号( <code>jobID</code> 或 <code>JOB_SPEC</code> )是作业在当前 <code>shell</code> 中的唯一标识.</p>
<h2 id="作业与进程"><a href="#作业与进程" class="headerlink" title="作业与进程"></a>作业与进程</h2><p>作业相比于进程是更高级的调度单位, 其定位类似于进程组, 但与进程组不同的是, 作业只维护其初始进程, 一旦所有的初始进程退出则代表作业执行完毕, 未结束的子进程不会被作业追踪, 如下例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">(sleep 20 &amp; sleep 2) &amp;</span><br><span class="line"><span class="built_in">jobs</span> -l</span><br><span class="line">pstree -apg $</span><br><span class="line">ps -ejfH | awk <span class="string">'$10 ~ /^sleep/ &#123;printf "%s %s -- PPID:%s, PGID:%s\n",$10,$11,$3,$4&#125;'</span></span><br><span class="line">sleep 2</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">jobs</span> -l</span><br><span class="line">pstree -apg $</span><br><span class="line">ps -ejfH | awk <span class="string">'$10 ~ /^sleep/ &#123;printf "%s %s -- PPID:%s, PGID:%s\n",$10,$11,$3,$4&#125;'</span></span><br><span class="line">pkill sleep</span><br></pre></td></tr></table></figure>

<p>运行这个例子可以得到如下输出, 可以看到整个作业初始只包括一个没有 <code>wait</code> 的 <code>bash</code> 进程 <code>19318</code> , 运行 <code>2</code> 秒后 <code>19321</code> 退出导致 <code>19318</code> 退出, 因此作业结束, 此时 <code>19319</code> 由于父进程退出而变为孤儿进程, 但其<strong>进程组</strong>号未改变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[1]+ 19318 Running                 ( sleep 20 &amp; sleep 2 ) &amp;</span><br><span class="line">bash,19317,19317 pgroup.sh</span><br><span class="line">  ├─bash,19318,19317 pgroup.sh  # 作业的初始进程</span><br><span class="line">  │   ├─sleep,19319,19317 20  # 作业运行中创建的子进程</span><br><span class="line">  │   └─sleep,19321,19317 2  # 作业运行中创建的子进程</span><br><span class="line">  └─pstree,19320,19317 -apg 19317</span><br><span class="line">sleep 20 -- PPID:19318, PGID:19317</span><br><span class="line">sleep 2 -- PPID:19318, PGID:19317</span><br><span class="line"></span><br><span class="line"># 进程 19321 退出 由于没有 wait 导致整个作业退出</span><br><span class="line">[1]+ 19318 Done                    ( sleep 20 &amp; sleep 2 )</span><br><span class="line">bash,19317,19317 pgroup.sh</span><br><span class="line">  └─pstree,19328,19317 -apg 19317</span><br><span class="line">sleep 20 -- PPID:1, PGID:19317  # 变为孤儿进程 但进程组号未变</span><br></pre></td></tr></table></figure>

<p>作业的存在是为了方便 <code>shell</code> 对前后台进程(进程组)进行管理, 一个 <code>shell</code> 进程在同一时刻只能存在一个前台作业但可以存在多个后台作业. 每个作业可以包含一个或多个进程, 具体体现为如下情况:</p>
<ul>
<li>作业中包含单个进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 50 &amp;</span><br><span class="line">[1] 20536  <span class="comment"># 作业号为 1, 包含的进程号为 20536</span></span><br><span class="line">&gt; <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 20536 Running                 sleep 50 &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>作业中包含进程及其子进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; (sleep 20 &amp; sleep 10 &amp; <span class="built_in">wait</span>) &amp;</span><br><span class="line">[1] 21111</span><br><span class="line">&gt; pstree -ap $</span><br><span class="line">bash,21023</span><br><span class="line">  ├─bash,21111  <span class="comment"># 作业的初始进程</span></span><br><span class="line">  │   ├─sleep,21112 20</span><br><span class="line">  │   └─sleep,21113 10</span><br><span class="line">  └─pstree,21116 -ap 21023</span><br></pre></td></tr></table></figure>

<ul>
<li>作业中包含多个进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 10 | sleep 8 &amp;  <span class="comment"># 管道两侧在 sub shell 中运行</span></span><br><span class="line">[1] 20689</span><br><span class="line">&gt; <span class="built_in">jobs</span> -l  <span class="comment"># 作业中包含两个初始进程</span></span><br><span class="line">[1]+ 20688 Running                 sleep 10</span><br><span class="line">     20689                       | sleep 8 &amp;</span><br></pre></td></tr></table></figure>

<h2 id="前台作业管理"><a href="#前台作业管理" class="headerlink" title="前台作业管理"></a>前台作业管理</h2><p>在一个 <code>shell</code> 会话中直接输入命令执行的作业会在前台运行, 前台作业会一直阻塞 <code>shell</code> 直到其执行完毕或被挂起. 前台作业能够优先处理传递给进程组的信号, 并且优先占用输入文件描述符. 以外部命令 <code>cat</code> 命令为例, 在启动后, <code>shell</code> 会把当前的前台进程组指定为新建立的 <code>cat</code> 进程组, 这样 <code>cat</code> 就接管了整个 <code>shell</code> 的标准输入, 标准输出和标准错误文件描述符. 命令的组合也可以作为前台任务被执行, 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"Hello World"</span>; sleep 10; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>要退出上面这个死循环需要给进程发送中断信号, 为了方便, 我们一般使用 <code>Ctrl + C</code> 直接给整个进程组发送 <code>SIGINT</code> 信号. 但如果我们要在不退出前台作业的基础上拿回终端控制权, 就需要给作业发送 <code>SIGTSTP</code> 或 <code>SIGSTOP</code> 信号来让他暂时挂起.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ping 127..0.0.1</span><br><span class="line">^Z  <span class="comment"># 按下 Ctrl + Z</span></span><br><span class="line">[1]+  Stopped                 ping 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>通过 <code>Ctrl + Z</code> 可以给 <code>shell</code> 中的前台作业发送 <code>SIGTSTP</code> , 这样 <code>ping</code> 命令就暂时停止了, 我们重新拿回了 <code>shell</code> 的控制权, 通过 <code>ps T</code> 命令可以查看当前 <code>shell</code> 终端关联的所有进程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps T</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 4731 pts/1    Ss     0:00 /bin/bash</span><br><span class="line"> 4738 pts/1    T      0:00 ping 127.0.0.1</span><br><span class="line"> 4891 pts/1    R+     0:00 ps T</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>ping</code> 命令并没有退出, 而且他的状态被改成了 <code>T</code> , 通过查阅 <code>man ps</code> 可以知道, <code>T</code> 状态代表进程被作业控制信号停止. 此外, 可以使用内置命令 <code>suspend</code> 挂起当前 <code>shell</code> .</p>
<h2 id="后台作业管理"><a href="#后台作业管理" class="headerlink" title="后台作业管理"></a>后台作业管理</h2><p>除了让前台作业挂起将其变为后台作业之外, 通过 <code>command &amp;</code> 的方式可以让命令直接在后台运行, 我们在刚才挂起的 <code>ping</code> 基础上再添加两个运行中的后台作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; xeyes &amp;</span><br><span class="line">&gt; xload &amp;</span><br></pre></td></tr></table></figure>

<p>通过 <code>jobs -l</code> 可以查看当前 <code>shell</code> 中的后台作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+  6528 Stopped                 ping 127.0.0.1</span><br><span class="line">[2]   7101 Running                 xeyes &amp;</span><br><span class="line">[3]-  7104 Running                 xload &amp;</span><br></pre></td></tr></table></figure>

<p>第一列 <code>[1]</code> 表示作业号 <code>JOB_SPEC</code> , 后面跟随的 <code>+</code> 表示其为当前作业, 或者说最近的被调往前台的作业, 而 <code>-</code> 表示当前作业的前一个作业, 我们可以通过 <code>%JOB_SPEC %+ %-</code> 的方式在命令中访问这些作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">fg</span> %2  <span class="comment"># 或 fg 2, 因为 fg 只对作业有效所以可以省略百分号</span></span><br><span class="line">xeyes</span><br><span class="line">^Z  <span class="comment"># 挂起</span></span><br><span class="line">[2]+  Stopped                 xeyes</span><br><span class="line">&gt; <span class="built_in">jobs</span>  <span class="comment"># 不带 l 选项则不显示进程号</span></span><br><span class="line">[1]-  Stopped                 ping 127.0.0.1  <span class="comment"># 减号表示前一个作业</span></span><br><span class="line">[2]+  Stopped                 xeyes  <span class="comment"># 加号表示当前作业</span></span><br><span class="line">[3]   Running                 xload &amp;</span><br><span class="line">&gt; <span class="built_in">fg</span>  <span class="comment"># 等价于 fg + 或 fg %+ 或 fg %%</span></span><br></pre></td></tr></table></figure>

<p>第二列数字 <code>6528</code> 为该作业包含的初始进程进程号, 初始进程可以为多个, 所有初始进程执行完毕则作业执行完毕. 第三列表示作业的状态, 包括以下几种:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 5 &amp;</span><br><span class="line">&gt; <span class="built_in">kill</span> %+  <span class="comment"># 等价于 kill %2 百分号不可省略</span></span><br><span class="line">&gt; <span class="built_in">jobs</span></span><br><span class="line">[1]+  Stopped                 ping 127.0.0.1  <span class="comment"># 停止</span></span><br><span class="line">[2]   Terminated              xeyes  <span class="comment"># 被终止</span></span><br><span class="line">[3]-  Running                 xload &amp;  <span class="comment"># 运行态</span></span><br><span class="line">[4]   Done                    sleep 5  <span class="comment"># 成功执行完毕并已经退出, 只会显示一次</span></span><br><span class="line">[5]   Hangup                  ping 127.0.0.1 &gt; /dev/null  <span class="comment"># 挂起 无特殊处理则退出</span></span><br></pre></td></tr></table></figure>

<p>最后一列是作业的运行命令文本, 在命令控制任务中可以使用 <code>%s</code> 和 <code>%?s</code> 通过匹配作业文本的方式指定作业:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">kill</span> -s int %ping  <span class="comment"># 给作业文本以 ping 开头的作业发送 SIGINT</span></span><br><span class="line">&gt; <span class="built_in">fg</span> %?eye  <span class="comment"># 把作业文本包含 eye 的作业提到前台</span></span><br></pre></td></tr></table></figure>

<p>我们还可以使用 <code>bg</code> 命令让挂起的后台作业直接运行, 而不必将其提到前台, 其用法类似于 <code>fg</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sleep 100</span><br><span class="line">^Z  <span class="comment"># 挂起</span></span><br><span class="line">[1]+  Stopped                 sleep 100</span><br><span class="line">&gt; <span class="built_in">bg</span> 1  <span class="comment"># 等价于 bg %1</span></span><br><span class="line">[1]+ sleep 100 &amp;</span><br><span class="line">&gt; <span class="built_in">jobs</span></span><br><span class="line">[1]+  Running                 sleep 100 &amp;</span><br></pre></td></tr></table></figure>

<p>但要注意, 为了防止后台作业与前台作业争抢输入资源, 只要后台作业执行到需要读取输入的代码段, 就会导致该作业被挂起, 这时使用 <code>bg</code> 命令无效.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">read</span> line; <span class="keyword">done</span> &amp;</span><br><span class="line">[1] 20780</span><br><span class="line">&gt; <span class="built_in">bg</span> 1</span><br><span class="line">[1]+ <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> line;</span><br><span class="line"><span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment"># 被输入挂起 仍处于停止状态</span></span><br><span class="line">[1]+  Stopped                 <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> line;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="作业控制命令与符号"><a href="#作业控制命令与符号" class="headerlink" title="作业控制命令与符号"></a>作业控制命令与符号</h2><p>作业控制命令及其用法可以总结为如下表格:<br>| 符号 | 描述 | 例子 |<br>| — | — | — |<br>| &amp; | 把作业放到后台 | <code>command &amp;</code> |<br>| %n | 作业列表中作业号为 <code>n</code> 的作业 | <code>kill %1</code> |<br>| %s | 作业列表中名称以字符串 <code>s</code> 开头的作业| <code>kill %xe</code> |<br>| %?s | 作业列表中名称包括字符串 <code>s</code> 的作业 | <code>jobs %?ping</code> |<br>| %% 或 %+ | 表示当前作业 | <code>kill %%</code>  <code>kill %+</code> |<br>| %- | 表示当前作业的上一个作业 | <code>bg %-</code> |<br>| Ctrl + Z | 挂起或停止作业 | <code>kill -s stop %ping</code> |<br>| jobs -l | 列出所有作业 | <code>jobs -l</code> |<br>| jobs -r | 列出所有正在运行的作业 | <code>jobs -r</code> |<br>| jobs -s | 列出所有被挂起的作业 | <code>jobs -s</code> |<br>| bg | 让作业在后台运行 | <code>bg %%</code> |<br>| fg | 把作业提到前台 | <code>fg %apt-get</code> |</p>
<h1 id="处理-SIGHUP-信号"><a href="#处理-SIGHUP-信号" class="headerlink" title="处理 SIGHUP 信号"></a>处理 SIGHUP 信号</h1><p>无论是前台作业还是后台作业, 他们都呈树状结构依附于 <code>shell</code> 进程, 在 <code>shell</code> 终端退出时如果存在后台作业, 则会提示 <code>There are stopped jobs.</code> , 如果忽略这个提示继续退出, <code>shell</code> 会向所有作业发送 <code>SIGHUP</code> 信号来进行清理. 如果我们需要某些后台进程在终端退出时仍然继续运行, 就需要对 <code>SIGHUP</code> 信号进行处理.</p>
<h2 id="外部命令-nohup"><a href="#外部命令-nohup" class="headerlink" title="外部命令 nohup"></a>外部命令 nohup</h2><p>使用 <code>nohup</code> 命令启动作业可以让该作业忽略 <code>SIGHUP</code> , 其用法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup ping 127.0.0.1 &amp;</span><br><span class="line">[1] 21222</span><br><span class="line">nohup: ignoring input and appending output to <span class="string">'nohup.out'</span></span><br><span class="line"><span class="comment"># exec ping 127.0.0.1 &amp; 也可以实现类似的效果</span></span><br><span class="line"><span class="comment"># 但 nohup 会自动帮你处理输出重定向</span></span><br></pre></td></tr></table></figure>

<p>退出当前终端并在另一个终端执行查找 <code>ping</code> 进程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps -ef | awk <span class="string">'$8~/^ping/ &#123;print "PID:"$2", PPID:"$3&#125;'</span></span><br><span class="line">PID:21222, PPID:1  <span class="comment"># 变为孤儿进程继续运行</span></span><br></pre></td></tr></table></figure>

<p>为了防止后台作业阻塞, <code>nohup</code> 会让作业忽略输入, 并将所有输出默认重定向到 <code>~/nohup.out</code> 文件中, 我们可以手动进行输出重定向, 而且会自动帮我们将标准错误重定向到标准输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup ping 127.0.0.1 &gt; outfile &amp;</span><br><span class="line">[1] 22505</span><br><span class="line">ignoring input and redirecting stderr to stdout</span><br><span class="line"></span><br><span class="line">&gt; nohup ping 127.0.0.1 &amp;&gt; outfile &amp;</span><br><span class="line">[2] 22523</span><br></pre></td></tr></table></figure>

<p>但要注意, <code>nohup</code> 命令后不可以通过 <code>(...)</code> 的方式在 <code>subshell</code> 中执行命令, 这样做会导致解释器将 <code>nohup</code> 视为函数从而导致语法错误:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup (sleep 120; <span class="built_in">echo</span> <span class="string">"job done"</span>) &amp;  <span class="comment"># 这么写会报错</span></span><br><span class="line">&gt; nohup bash -c <span class="string">'sleep 120; echo "job done"'</span> &amp;  <span class="comment"># 可以正常执行</span></span><br><span class="line">[1] 25758</span><br><span class="line">&gt; pstree -ap $</span><br><span class="line">bash,23897</span><br><span class="line">  ├─bash,25758 -c sleep 120; <span class="built_in">echo</span> <span class="string">"job done"</span></span><br><span class="line">  │   └─sleep,25759 120</span><br><span class="line">  └─pstree,25764 -ap 23897</span><br></pre></td></tr></table></figure>

<h2 id="内置命令-disown"><a href="#内置命令-disown" class="headerlink" title="内置命令 disown"></a>内置命令 disown</h2><p><code>nohup</code> 的不足之处在于必须在程序运行前指定是否忽略 <code>SIGHUP</code> 信号, 如果我们希望对运行中的作业进行修改可以使用内置命令 <code>disown</code> , 其用法如下:</p>
<ul>
<li><code>disown %n</code> : 把编号为 <code>n</code> 的作业从列表中剥离, 这回该作业所有的输出消失, 而且无法进行作业控制.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; ping 127.0.0.1 &gt; /dev/null &amp;</span><br><span class="line">[1] 29748</span><br><span class="line">&gt; <span class="built_in">disown</span> %1</span><br><span class="line">&gt; <span class="built_in">jobs</span>  <span class="comment"># 没有输出</span></span><br><span class="line">&gt; ps -f 29748</span><br><span class="line">UID        PID  PPID  C STIME TTY      STAT   TIME CMD</span><br><span class="line">remilia  29748 28309  0 15:10 pts/3    S      0:00 ping 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出终端并在另一个终端中查看该进程</span></span><br><span class="line">&gt; ps -f 29748  <span class="comment"># 变为孤儿进程继续运行</span></span><br><span class="line">UID        PID  PPID  C STIME TTY      STAT   TIME CMD</span><br><span class="line">remilia  29748     1  0 15:10 ?        S      0:00 ping 127.0.0.1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>disown -h %n</code> : 让编号为 <code>n</code> 的作业忽略退出时产生的 <code>SIGHUP</code> , 这种方法不会从作业列表中删除该作业, 因此可以继续使用作业控制命令进行管理.</li>
<li><code>disown -r</code> : 从作业列表中剥离所有运行中的作业.</li>
<li><code>disown -a</code> :  从作业列表中剥离所有作业.</li>
</ul>
<p>该命令的一个缺点是不会自动进行输出重定向, 如果我们需要保存作业的输出可以使用 <code>gdb</code> 在程序运行时修改文件描述符的指向.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; python3 logerr.py &amp;</span><br><span class="line">&gt; sudo gdb -p &#96;pgrep python3&#96; </span><br><span class="line">(gdb) p close(2)  # 删除标准错误</span><br><span class="line">$1 &#x3D; 0</span><br><span class="line">(gdb) p creat(&quot;&#x2F;tmp&#x2F;pyout&quot;, 0600)  # 创建文件自动连接到标准错误</span><br><span class="line">$2 &#x3D; 2</span><br><span class="line">(gdb) q  # 选 yes</span><br><span class="line"></span><br><span class="line">&gt; sudo ls -l &#x2F;proc&#x2F;31586&#x2F;fd&#x2F;2</span><br><span class="line">l-wx------ 1 remilia remilia 64 Mar 22 15:36 &#x2F;proc&#x2F;31586&#x2F;fd&#x2F;2 -&gt; &#x2F;tmp&#x2F;pyout</span><br></pre></td></tr></table></figure>

<h2 id="选项-huponexit"><a href="#选项-huponexit" class="headerlink" title="选项 huponexit"></a>选项 huponexit</h2><p><code>huponexit</code> 是 <code>bash</code> 中的选项, 其用法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">shopt</span> huponexit  <span class="comment"># 查看选项是否开启</span></span><br><span class="line">&gt; <span class="built_in">shopt</span> -s huponexit  <span class="comment"># 开启选项</span></span><br></pre></td></tr></table></figure>

<p>开启该选项则会让该 <code>shell</code> 会话中的所有后台作业忽略由该会话退出时执行 <code>exit</code> 所产生的 <code>SIGHUP</code> , 其他方式传递来的 <code>SIGHUP</code> 则不会被忽略, <code>SIGHUP</code> 的传播过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会话 -- SIGHUP --&gt; bash ( huponexit ) -- SIGHUP --&gt; 作业</span><br></pre></td></tr></table></figure>

<p>如果 <code>bash</code> 中开启了 <code>huponexit</code> , 则在会话退出时不会给子进程(作业)分发 <code>SIGHUP</code> 信号.</p>
<h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><p>我们也可以通过让后台作业变为孤儿进程的方式实现忽略父 <code>shell</code> 传递来的 <code>SIGHUP</code> 信号:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subshell 没有 wait 他自己的后台任务因此提前退出</span></span><br><span class="line"><span class="comment"># 这种方式可以自定义重定向输出文件 但无法进行作业管理</span></span><br><span class="line">&gt; (ping 127.0.0.1 &gt;/dev/null &amp;)</span><br><span class="line">&gt; ps -f `pgrep ping` </span><br><span class="line">UID        PID  PPID  C STIME TTY      STAT   TIME CMD</span><br><span class="line">remilia    847     1  0 15:49 pts/4    S      0:00 ping 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>另外还有一些工具如 <code>screen</code> , <code>tmux</code> , <code>dtach</code> 等可以实现更高级的功能.</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul>
<li><a href="http://www.linuxplus.org/kb/x6756.html" target="_blank" rel="noopener">高级Bash脚本编程指南</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-bash-s-job-control-to-manage-foreground-and-background-processes" target="_blank" rel="noopener">How To Use Bash’s Job Control</a></li>
<li><a href="https://etbe.coker.com.au/2008/02/27/redirecting-output-from-a-running-process/" target="_blank" rel="noopener">Redirecting Output from a Running Process</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/" data-id="ck8oiuufn0006e6axbk6ydtp4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/历史记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/">bash/mechanism/历史记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="显示历史记录"><a href="#显示历史记录" class="headerlink" title="显示历史记录"></a>显示历史记录</h2><p>使用 <code>history</code> 可以查看当前用户最近执行的 <code>HISTSIZE</code> 条命令，这些记录被存储在 <code>HISTFILE</code> 文件中，在 <code>bash</code> 启动时会自动加载到历史记录缓冲队列，其简单使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">history</span>  <span class="comment"># 显示全部历史记录</span></span><br><span class="line">    1  ip a</span><br><span class="line">    2  <span class="built_in">exit</span></span><br><span class="line">    3  ls -la</span><br><span class="line">    4  <span class="built_in">history</span></span><br><span class="line">&gt; <span class="built_in">history</span> 2  <span class="comment"># 显示最后两条历史记录</span></span><br><span class="line">    4  <span class="built_in">history</span></span><br><span class="line">    5  <span class="built_in">history</span> 2</span><br></pre></td></tr></table></figure>

<h2 id="搜索与批量查询"><a href="#搜索与批量查询" class="headerlink" title="搜索与批量查询"></a>搜索与批量查询</h2><p>使用 <code>Ctrl + R</code> 快捷键可以进入历史记录搜索模式，根据用户输入的字符按照<strong>最近最相似</strong>原则将搜索结果打印到命令提示符后面，输入回车可以直接执行这条结果。另一种方式是使用 <code>grep</code> 配合管道进行批量搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">history</span> | grep ffmpeg | grep gif | grep yuv444p  </span><br><span class="line"> 119  ffmpeg -y -f gif -i 79557166.gif -c:v libx264 -vf format=yuv444p yuv444p.mp4  </span><br><span class="line"> 120  ffmpeg -y -f gif -i 79557166.gif -c:v libx264 -vf format=yuv444p yuv444p.mkv</span><br></pre></td></tr></table></figure>

<h2 id="立即执行（危险）"><a href="#立即执行（危险）" class="headerlink" title="立即执行（危险）"></a>立即执行（危险）</h2><p>使用 <code>!!</code> 能够立即执行历史记录中的最后一条命令，也就是重复上一条命令；使用 <code>![number]</code> 能够根据 <code>number</code> 执行对应编号的历史命令；使用 <code>![string]</code> 能够根据 <code>string</code> 按照<strong>最近最相似</strong>原则执行历史命令。这类命令最人性化的是会在执行前打印要执行的命令（让你知道系统是怎么挂的）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Sun 23 Feb 2020 06:18:16 PM CST</span><br><span class="line">&gt; !!  <span class="comment"># 不安全</span></span><br><span class="line">date  </span><br><span class="line">Sun 23 Feb 2020 06:18:18 PM CST</span><br><span class="line">&gt; !907  <span class="comment"># 危险</span></span><br><span class="line">make  </span><br><span class="line">make: \*\*\* No targets specified and no makefile found.  Stop.</span><br><span class="line">&gt; !shut  <span class="comment"># 非常危险</span></span><br><span class="line">shutdown now</span><br></pre></td></tr></table></figure>

<p>通过 <code>!</code> 开头的命令直接执行对应的历史记录是十分危险的，尤其是在高权限用户环境下，因此建议在执行之前通过以下方式查看对应的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; !!:p      <span class="comment">#查看记录中最后一条命令</span></span><br><span class="line">&gt; !123:p    <span class="comment">#查看记录中第123条命令</span></span><br><span class="line">&gt; !sys:p    <span class="comment">#查看记录中sys开头的最近一条命令</span></span><br></pre></td></tr></table></figure>

<h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>使用 <code>history -d &lt;hist_num&gt;</code> 可以删除指定序号的历史记录，该模式只接收一个参数，其他参数会被忽略，利用这一特性可以实现在bash中执行不被记录的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"secret command"</span>;<span class="built_in">history</span> -d $(<span class="built_in">history</span> 1)</span><br><span class="line">secret <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p>如果你想完全清除当前会话内的使用痕迹，可以使用 <code>history -c</code> 清空历史记录缓冲队列，值得注意的是这个命令不会清空历史记录文件。</p>
<blockquote>
<p>[warning]<strong>注意</strong>：除了上述方法外，用户还可以通过 <code>unset HISTFILE</code> 直接取消历史记录功能，这对服务器的日常维护来说是十分危险的（参见本章练习）。</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>在退出终端时bash会自动将当前会话中执行过的命令写入历史记录文件中，默认写入方式为覆盖。你也可以通过 <code>-w</code> 和 <code>-a</code> 模式将当前会话中的命令手动写入文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">history</span> -w  <span class="comment"># 缓冲队列覆盖写入文件</span></span><br><span class="line">&gt; <span class="built_in">history</span> -a  <span class="comment"># 当前会话的命令追加写入文件</span></span><br></pre></td></tr></table></figure>

<h1 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h1><p>以 <code>Ubuntu 20.04 LTS</code> 为例，默认情况下历史记录相关的环境变量被定义在 <code>~/.bashrc</code> 文件中。</p>
<h2 id="添加时间戳"><a href="#添加时间戳" class="headerlink" title="添加时间戳"></a>添加时间戳</h2><p>通过修改 <code>HISTTIMEFORMAT</code> 变量可以对历史记录添加时间戳， <code>%F</code> 代表日期， <code>%T</code> 代表时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">export</span> HISTTIMEFORMAT=<span class="string">'%F %T '</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'history with time'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">history</span> 1</span></span><br><span class="line">1032  2020-02-23 17:01:26 history</span><br></pre></td></tr></table></figure>

<h2 id="修改记录策略"><a href="#修改记录策略" class="headerlink" title="修改记录策略"></a>修改记录策略</h2><p>通过修改 <code>HISTCONTROL</code> 变量可以控制 <code>history</code> 的记录策略，如下表所示：<br>|   可选值  |  记录策略   |<br>| — | — |<br>|  ignoredups   |   默认，不记录<strong>连续</strong>的相同命令  |<br>|  ignorespace   |   不记录空格开头的命令  |<br>|  ignoreboth   |   ignoredups 和 ignorespace 的组合  |<br>|  erasedups   |   不记录重复的命令  |</p>
<p>我们还可以通过设置 <code>HISTIGNORE</code> 变量指定要忽略的命令，命令之间用 <code>:</code> 分隔：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">'export HISTIGNORE="ls:cd"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="修改存储文件"><a href="#修改存储文件" class="headerlink" title="修改存储文件"></a>修改存储文件</h2><p>当前用户的历史记录默认存储到 <code>~/.bash_history</code> 文件中，可以通过修改 <code>HISTFILE</code> 变量改变历史记录存储的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">'export HISTFILE="&lt;new_histfile_path&gt;"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="修改存储大小"><a href="#修改存储大小" class="headerlink" title="修改存储大小"></a>修改存储大小</h2><p>变量 <code>HISTSIZE</code> 决定了使用 <code>history</code> 时<strong>显示</strong>的记录数量，其默认值为 <code>1000</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$HISTSIZE</span></span><br><span class="line">1000</span><br><span class="line">&gt; HISTSIZE=200 <span class="comment"># 仅针对当前会话生效</span></span><br><span class="line">&gt; sed -i <span class="string">'s/^HISTSIZE=1000/HISTSIZE=200/'</span> ~/.bashrc <span class="comment"># 永久生效</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$HISTSIZE</span></span><br><span class="line">200</span><br></pre></td></tr></table></figure>

<p>变量 <code>HISTFILESIZE</code> 定义了<strong>存储</strong>在文件中的历史命令总数，默认值为 <code>2000</code> 。历史记录的存储方式类似于队列， <code>bash</code> 初始化时会将 <code>HISTFILE</code> 文件中存储的所有历史记录加载到内存中，以队列的形式存储，用户在使用过程中产生的命令也会被添加到队列中，每次用户调用 <code>history</code> 都会显示最近的 <code>HISTSIZE</code> 条记录。</p>
<h2 id="修改存储策略"><a href="#修改存储策略" class="headerlink" title="修改存储策略"></a>修改存储策略</h2><p>在终端退出时会将当前会话（session）中产生的记录写入到文件中，为了防止同时开启多个终端导致历史记录丢失，建议在 <code>~/.bashrc</code> 文件中添加 <code>shopt -s histappend</code> ，让终端在退出时将当前会话产生的历史记录追加写入到 <code>HISTFILE</code> 文件中。</p>
<blockquote>
<p>[warning] <strong>注意</strong>：默认情况下的历史记录写入方式为覆盖，例如：开启终端A -&gt; 开启终端B -&gt; 关闭终端A -&gt; 关闭终端B，这个操作序列会导致终端A在运行过程中产生的历史记录全部丢失。</p>
</blockquote>
<p>断电、非法关机等特殊情况会让 <code>bash</code> 无法正常结束，进而导致当前会话的历史记录丢失。可以在 <code>~/.bashrc</code> 文件中添加以下内容实现自动追加写入每条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROMPT_COMMAND=”<span class="built_in">history</span> -a”</span><br></pre></td></tr></table></figure>

<p>在 <code>bash</code> 的配置文件中，如果设置了 <code>PROMPT_COMMAND</code> 环境变量，则在每次显示命令提示符（例如：`remilia@CT7GK:~# 基本用法</p>
<h2 id="显示历史记录-1"><a href="#显示历史记录-1" class="headerlink" title="显示历史记录"></a>显示历史记录</h2><p>使用 <code>history</code> 可以查看当前用户最近执行的 <code>HISTSIZE</code> 条命令，这些记录被存储在 <code>HISTFILE</code> 文件中，在 <code>bash</code> 启动时会自动加载到历史记录缓冲队列，其简单使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">history</span>  <span class="comment"># 显示全部历史记录</span></span><br><span class="line">    1  ip a</span><br><span class="line">    2  <span class="built_in">exit</span></span><br><span class="line">    3  ls -la</span><br><span class="line">    4  <span class="built_in">history</span></span><br><span class="line">&gt; <span class="built_in">history</span> 2  <span class="comment"># 显示最后两条历史记录</span></span><br><span class="line">    4  <span class="built_in">history</span></span><br><span class="line">    5  <span class="built_in">history</span> 2</span><br></pre></td></tr></table></figure>

<h2 id="搜索与批量查询-1"><a href="#搜索与批量查询-1" class="headerlink" title="搜索与批量查询"></a>搜索与批量查询</h2><p>使用 <code>Ctrl + R</code> 快捷键可以进入历史记录搜索模式，根据用户输入的字符按照<strong>最近最相似</strong>原则将搜索结果打印到命令提示符后面，输入回车可以直接执行这条结果。另一种方式是使用 <code>grep</code> 配合管道进行批量搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">history</span> | grep ffmpeg | grep gif | grep yuv444p  </span><br><span class="line"> 119  ffmpeg -y -f gif -i 79557166.gif -c:v libx264 -vf format=yuv444p yuv444p.mp4  </span><br><span class="line"> 120  ffmpeg -y -f gif -i 79557166.gif -c:v libx264 -vf format=yuv444p yuv444p.mkv</span><br></pre></td></tr></table></figure>

<h2 id="立即执行（危险）-1"><a href="#立即执行（危险）-1" class="headerlink" title="立即执行（危险）"></a>立即执行（危险）</h2><p>使用 <code>!!</code> 能够立即执行历史记录中的最后一条命令，也就是重复上一条命令；使用 <code>![number]</code> 能够根据 <code>number</code> 执行对应编号的历史命令；使用 <code>![string]</code> 能够根据 <code>string</code> 按照<strong>最近最相似</strong>原则执行历史命令。这类命令最人性化的是会在执行前打印要执行的命令（让你知道系统是怎么挂的）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Sun 23 Feb 2020 06:18:16 PM CST</span><br><span class="line">&gt; !!  <span class="comment"># 不安全</span></span><br><span class="line">date  </span><br><span class="line">Sun 23 Feb 2020 06:18:18 PM CST</span><br><span class="line">&gt; !907  <span class="comment"># 危险</span></span><br><span class="line">make  </span><br><span class="line">make: \*\*\* No targets specified and no makefile found.  Stop.</span><br><span class="line">&gt; !shut  <span class="comment"># 非常危险</span></span><br><span class="line">shutdown now</span><br></pre></td></tr></table></figure>

<p>通过 <code>!</code> 开头的命令直接执行对应的历史记录是十分危险的，尤其是在高权限用户环境下，因此建议在执行之前通过以下方式查看对应的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; !!:p      <span class="comment">#查看记录中最后一条命令</span></span><br><span class="line">&gt; !123:p    <span class="comment">#查看记录中第123条命令</span></span><br><span class="line">&gt; !sys:p    <span class="comment">#查看记录中sys开头的最近一条命令</span></span><br></pre></td></tr></table></figure>

<h2 id="删除记录-1"><a href="#删除记录-1" class="headerlink" title="删除记录"></a>删除记录</h2><p>使用 <code>history -d &lt;hist_num&gt;</code> 可以删除指定序号的历史记录，该模式只接收一个参数，其他参数会被忽略，利用这一特性可以实现在bash中执行不被记录的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"secret command"</span>;<span class="built_in">history</span> -d $(<span class="built_in">history</span> 1)</span><br><span class="line">secret <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p>如果你想完全清除当前会话内的使用痕迹，可以使用 <code>history -c</code> 清空历史记录缓冲队列，值得注意的是这个命令不会清空历史记录文件。</p>
<blockquote>
<p>[warning]<strong>注意</strong>：除了上述方法外，用户还可以通过 <code>unset HISTFILE</code> 直接取消历史记录功能，这对服务器的日常维护来说是十分危险的（参见本章练习）。</p>
</blockquote>
<h2 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h2><p>在退出终端时bash会自动将当前会话中执行过的命令写入历史记录文件中，默认写入方式为覆盖。你也可以通过 <code>-w</code> 和 <code>-a</code> 模式将当前会话中的命令手动写入文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">history</span> -w  <span class="comment"># 缓冲队列覆盖写入文件</span></span><br><span class="line">&gt; <span class="built_in">history</span> -a  <span class="comment"># 当前会话的命令追加写入文件</span></span><br></pre></td></tr></table></figure>

<h1 id="高级设置-1"><a href="#高级设置-1" class="headerlink" title="高级设置"></a>高级设置</h1><p>以 <code>Ubuntu 20.04 LTS</code> 为例，默认情况下历史记录相关的环境变量被定义在 <code>~/.bashrc</code> 文件中。</p>
<h2 id="添加时间戳-1"><a href="#添加时间戳-1" class="headerlink" title="添加时间戳"></a>添加时间戳</h2><p>通过修改 <code>HISTTIMEFORMAT</code> 变量可以对历史记录添加时间戳， <code>%F</code> 代表日期， <code>%T</code> 代表时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">export</span> HISTTIMEFORMAT=<span class="string">'%F %T '</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'history with time'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">history</span> 1</span></span><br><span class="line">1032  2020-02-23 17:01:26 history</span><br></pre></td></tr></table></figure>

<h2 id="修改记录策略-1"><a href="#修改记录策略-1" class="headerlink" title="修改记录策略"></a>修改记录策略</h2><p>通过修改 <code>HISTCONTROL</code> 变量可以控制 <code>history</code> 的记录策略，如下表所示：<br>|   可选值  |  记录策略   |<br>| — | — |<br>|  ignoredups   |   默认，不记录<strong>连续</strong>的相同命令  |<br>|  ignorespace   |   不记录空格开头的命令  |<br>|  ignoreboth   |   ignoredups 和 ignorespace 的组合  |<br>|  erasedups   |   不记录重复的命令  |</p>
<p>我们还可以通过设置 <code>HISTIGNORE</code> 变量指定要忽略的命令，命令之间用 <code>:</code> 分隔：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">'export HISTIGNORE="ls:cd"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="修改存储文件-1"><a href="#修改存储文件-1" class="headerlink" title="修改存储文件"></a>修改存储文件</h2><p>当前用户的历史记录默认存储到 <code>~/.bash_history</code> 文件中，可以通过修改 <code>HISTFILE</code> 变量改变历史记录存储的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">'export HISTFILE="&lt;new_histfile_path&gt;"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="修改存储大小-1"><a href="#修改存储大小-1" class="headerlink" title="修改存储大小"></a>修改存储大小</h2><p>变量 <code>HISTSIZE</code> 决定了使用 <code>history</code> 时<strong>显示</strong>的记录数量，其默认值为 <code>1000</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$HISTSIZE</span></span><br><span class="line">1000</span><br><span class="line">&gt; HISTSIZE=200 <span class="comment"># 仅针对当前会话生效</span></span><br><span class="line">&gt; sed -i <span class="string">'s/^HISTSIZE=1000/HISTSIZE=200/'</span> ~/.bashrc <span class="comment"># 永久生效</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$HISTSIZE</span></span><br><span class="line">200</span><br></pre></td></tr></table></figure>

<p>变量 <code>HISTFILESIZE</code> 定义了<strong>存储</strong>在文件中的历史命令总数，默认值为 <code>2000</code> 。历史记录的存储方式类似于队列， <code>bash</code> 初始化时会将 <code>HISTFILE</code> 文件中存储的所有历史记录加载到内存中，以队列的形式存储，用户在使用过程中产生的命令也会被添加到队列中，每次用户调用 <code>history</code> 都会显示最近的 <code>HISTSIZE</code> 条记录。</p>
<h2 id="修改存储策略-1"><a href="#修改存储策略-1" class="headerlink" title="修改存储策略"></a>修改存储策略</h2><p>在终端退出时会将当前会话（session）中产生的记录写入到文件中，为了防止同时开启多个终端导致历史记录丢失，建议在 <code>~/.bashrc</code> 文件中添加 <code>shopt -s histappend</code> ，让终端在退出时将当前会话产生的历史记录追加写入到 <code>HISTFILE</code> 文件中。</p>
<blockquote>
<p>[warning] <strong>注意</strong>：默认情况下的历史记录写入方式为覆盖，例如：开启终端A -&gt; 开启终端B -&gt; 关闭终端A -&gt; 关闭终端B，这个操作序列会导致终端A在运行过程中产生的历史记录全部丢失。</p>
</blockquote>
<p>断电、非法关机等特殊情况会让 <code>bash</code> 无法正常结束，进而导致当前会话的历史记录丢失。可以在 <code>~/.bashrc</code> 文件中添加以下内容实现自动追加写入每条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROMPT_COMMAND=”<span class="built_in">history</span> -a”</span><br></pre></td></tr></table></figure>

<p>在 <code>bash</code> 的配置文件中，如果设置了 <code>PROMPT_COMMAND</code> 环境变量，则在每次显示命令提示符（例如：）之前，该变量的值将被作为命令执行，这里我们设置为自动执行执行 <code>history -a</code> ，将历史记录追加写入到文件中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/" data-id="ck8oiuufo0007e6ax5urq5l5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/退出状态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/">bash/mechanism/退出状态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h1><h2 id="程序的退出状态"><a href="#程序的退出状态" class="headerlink" title="程序的退出状态"></a>程序的退出状态</h2><p>当一个程序结束时会向父进程报告自己的退出状态( <code>exit status</code> ). 通过传递 <code>int</code> 类型的变量给库函数 <code>exit</code> 或系统调用 <code>_exit</code> 可以设置当前程序的退出状态, 在 <code>Linux</code> 中, 通过 <code>WEXITSTATUS</code> 返回的退出状态的值域为 <code>[0, 255]</code> 之间的整数 . 如果传递的值不在这个范围内, 内核会自动帮你强转为 <code>u_int8_t</code> . 通过 <code>waitpid</code> 库函数可以得到子进程的退出状态, 其值存储在参数 <code>wstatus</code> 的低 <code>8</code> 位中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在 wait.h 中</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> WEXITSTATUS(status)	__WEXITSTATUS (status)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在 waitstatus.h 中</span></span><br><span class="line"><span class="comment">/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__WEXITSTATUS(status)	(((status) &amp; 0xff00) &gt;&gt; 8)</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子展示了如何使用 <code>waitpid</code> 及相关宏函数获取子进程的退出状态:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT_EXIT 10086</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHILD_EXIT -10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> wstatus;</span><br><span class="line">        <span class="comment">// 父进程等待子进程执行完毕, 用 WUNTRACED 选项追踪已结束的子进程</span></span><br><span class="line">        <span class="keyword">pid_t</span> child_pid = waitpid(pid, &amp;wstatus, WUNTRACED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(wstatus))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child exit status: %d\n"</span>, WEXITSTATUS(wstatus));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            perror(<span class="string">"Bad wait status\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(PARENT_EXIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程立即退出, 因此需要父进程设置 WUNTRACED</span></span><br><span class="line">        <span class="built_in">exit</span>(CHILD_EXIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理 fork 时出现的错误</span></span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行上例可以得到被强转后的状态码, 我们使用 <code>WIFEXITED</code> 判断等待的子进程是否执行成功, 然后对执行成功子进程使用 <code>WEXITSTATUS</code> 获取其退出状态. 对程序来说, 最终的退出状态就是主进程的退出状态.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc ecitcode.c;./a.out;<span class="built_in">echo</span> <span class="string">"Parent exit status: $?"</span></span><br><span class="line">Child <span class="built_in">exit</span> status: 246  <span class="comment"># -10 强转为 uint8</span></span><br><span class="line">Parent <span class="built_in">exit</span> status: 102  <span class="comment"># 10086 强转为 uint8</span></span><br></pre></td></tr></table></figure>

<p>在 <code>POSIX</code> 标准中规定退出状态 <code>0</code> 代表该程序正常退出, <code>1</code> 代表发生错误, 其他数字由程序自行规定, 因此在 <code>glibc</code> 的 <code>stdlib.h</code> 中仅定义了如下宏:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_FAILURE    1       <span class="comment">/* Failing exit status.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_SUCCESS    0       <span class="comment">/* Successful exit status.  */</span></span></span><br></pre></td></tr></table></figure>

<p>程序本身一般会在文档中事先约定每种退出状态代表的退出原因( <code>termination</code> ), 例如在 <code>ls</code> 的帮助文档中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls --<span class="built_in">help</span></span><br><span class="line">...其他内容...</span><br><span class="line">Exit status:  <span class="comment"># 退出状态</span></span><br><span class="line"> 0  <span class="keyword">if</span> OK,  <span class="comment"># 正常执行</span></span><br><span class="line"> 1  <span class="keyword">if</span> minor problems  <span class="comment"># 次要问题, 例如: 无法访问子目录</span></span><br><span class="line"> 2  <span class="keyword">if</span> serious trouble  <span class="comment"># 严重错误, 例如: 无法访问命令行参数</span></span><br><span class="line">...其他内容...</span><br></pre></td></tr></table></figure>

<h2 id="命令的退出状态"><a href="#命令的退出状态" class="headerlink" title="命令的退出状态"></a>命令的退出状态</h2><p>在 <code>bash</code> 中会记录所执行命令的退出状态, 可以通过 <code>$?</code> 获取最近执行的命令的退出状态. <code>bash</code> 自身的退出状态为执行的最后一条命令的退出状态, 也就等价于显式指定 <code>exit $?</code> . 如果没有执行任何命令就退出, 则 <code>bash</code> 的退出状态为 <code>0</code> , 要注意在 <code>bash</code> 中用 <code>0</code> 表示 <code>true</code> , 用非零表示 <code>false</code> .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 exit 显式指定退出状态</span></span><br><span class="line">&gt; bash</span><br><span class="line">&gt; <span class="built_in">exit</span> 98</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">98</span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么也不执行则退出状态为 0</span></span><br><span class="line">&gt; bash</span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># Ctrl + D 退出</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认为最后一条命令的退出状态</span></span><br><span class="line">&gt; bash</span><br><span class="line">&gt; ecasd</span><br><span class="line">ecasd: <span class="built_in">command</span> not found</span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># Ctrl + D 退出</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">127</span><br></pre></td></tr></table></figure>

<p>在 <code>bash</code> 中对不同种类命令的退出状态作出如下规定:</p>
<p><strong>内置命令:</strong> 由于内置命令执行时不需要启动额外的子进程, 因此需要用返回值模拟退出状态. 每个函数都定义了自己的退出状态, 例如: 内置命令 <code>source</code> 将脚本文件的最后一个命令的返回状态作为命令的返回状态. <code>bash</code> 中所有的内置命令都用退出状态 <code>2</code> 表示用法错误, 例如: 选项错误, 缺少参数.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> -+-  <span class="comment"># 错误的参数</span></span><br><span class="line">bash: <span class="built_in">cd</span>: -+: invalid option</span><br><span class="line"><span class="built_in">cd</span>: usage: <span class="built_in">cd</span> [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>外部命令:</strong> 外部命令的退出状态就是使用 <code>waitpid</code> 得到的子进程的退出状态, 如果子进程在执行过程被编号为 <code>N</code> 的信号所终止, 则得到的退出状态就为 <code>128+N</code> .</p>
<p><strong>Shell 函数:</strong> 定义 <code>shell</code> 函数时, 函数名与之前已定义的只读函数名相同则退出状态为 <code>1</code> , 当发生语法错误则退出状态为 <code>2</code> . 执行 <code>shell</code> 函数时, 函数中最后执行的一条命令的退出状态就是整个函数的退出状态.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二次定义只读函数报错</span></span><br><span class="line">&gt; <span class="function"><span class="title">func</span></span> () &#123; <span class="built_in">echo</span>; &#125;</span><br><span class="line">&gt; <span class="built_in">readonly</span> -f func</span><br><span class="line">&gt; func; <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">&gt; <span class="function"><span class="title">func</span></span> () &#123; <span class="built_in">echo</span> poi; &#125;</span><br><span class="line">bash: func: <span class="built_in">readonly</span> <span class="keyword">function</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数发生语法错误</span></span><br><span class="line">&gt; <span class="function"><span class="title">fune</span></span> () &#123;aa&#125;</span><br><span class="line">bash: syntax error near unexpected token <span class="string">'&#123;aa&#125;'</span></span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的退出状态是最后执行的命令的退出状态</span></span><br><span class="line">&gt; <span class="function"><span class="title">funr</span></span> () &#123; <span class="built_in">echo</span>; <span class="built_in">return</span> 6; &#125;</span><br><span class="line">&gt; funr; <span class="built_in">echo</span> $?</span><br><span class="line">   <span class="comment"># echo 打印的空行</span></span><br><span class="line">6  <span class="comment"># return 6 是函数中最后执行的命令</span></span><br></pre></td></tr></table></figure>

<p><strong>表达式:</strong> 使用 <code>((...))</code> 或 <code>let</code> 修饰的表达式的退出状态取决于表达式的值, 如果表达式的值为 <code>0</code> 则退出状态为 <code>1</code> ; 如果表达式的值为非零, 则退出状态为 <code>0</code> .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">let</span> 0+0; <span class="built_in">echo</span> $?</span><br><span class="line">1  <span class="comment"># 表达式值为零</span></span><br><span class="line">&gt; ((7-5)); <span class="built_in">echo</span> $?</span><br><span class="line">0  <span class="comment"># 表达式值非零</span></span><br></pre></td></tr></table></figure>

<p><strong>命令列表:</strong> 用 <code>;</code> , <code>&amp;</code> , <code>&amp;&amp;</code> , <code>||</code> 连接命令被称为命令列表, 其中用 <code>&amp;&amp;</code> 和 <code>||</code> 连接的命令使用左关联( <code>left associativity</code> )模式执行列表中的命令. 整个命令列表的退出状态为最后一条命令的退出状态. 此外, <code>$( LISTS )</code> 以及流程控制结构如: <code>for</code> , <code>while</code> 等的返回状态也是结构中的命令列表的退出状态.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 功能: 能ping通baidu.com则输出 `baidu.com is up` ， 否则输出 `baidu.com is down` 。</span></span><br><span class="line">&gt; ping -c1 baidu.com &amp;&gt; /dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">'baidu.com is up'</span> || <span class="built_in">echo</span> <span class="string">'baidu.com is down'</span></span><br><span class="line">baidu.com is down</span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">0  <span class="comment"># 无论是否能 ping 通, 命令列表的退出状态都等于最后一条命令的退出状态</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!1INFo]<br>左关联模式被广泛应用于各种语言的逻辑运算符优化中. 对于逻辑与运算符 <code>&amp;&amp;</code> , 以 <code>eq1 &amp;&amp; eq2</code> 为例, 只有当两边都为 <code>True</code> 才会返回 <code>True</code> , 因此当 <code>eq1</code> 为 <code>False</code> 时, <code>eq2</code> 不会执行; 对于逻辑或运算符 <code>||</code> , 以 <code>eq1 || eq2</code> 为例, 只要两边有一个 <code>True</code> 就会返回 <code>True</code> , 因此当 <code>eq1</code> 为 <code>True</code> 时, <code>eq2</code> 不会执行。</p>
</blockquote>
<p><strong>脚本:</strong> 使用 <code>.</code> 或 <code>source</code> 运行脚本文件等同于在当前 <code>bash</code> 中执行代码块, 脚本中最后执行的命令的退出状态就是脚本的退出状态. 使用 <code>./脚本名</code> 或 <code>bash 脚本名</code> 的方式执行脚本文件等同于执行外部命令, 脚本的退出状态就是外部命令 <code>bash</code> 的退出状态.</p>
<blockquote>
<p>[!1WARN]<br>如果脚本中最后执行的命令是 <code>exit</code> , 那么使用 <code>.</code> 或 <code>source</code> 执行该脚本文件在执行结束后会退出当前 <code>bash</code> .</p>
</blockquote>
<p><strong>后台作业与协作进程:</strong> 使用不带选项的 <code>wait</code> 命令可以获得最后一个执行完毕的后台作业的退出状态, 如果使用 <code>wait -n &lt;jobsec&gt;</code> 可以获得指定后台作业的退出状态, 如果作业不存在则退出状态为 <code>127</code> . 使用 <code>coproc</code> 在 <code>sub shell</code> 中执行的命令的退出状态和后台作业一样可以被 <code>wait</code> 获取, <code>coproc</code> 自身的退出状态始终为 <code>0</code> .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; sleep 10; aad; &#125; &amp;</span><br><span class="line">[1] 558</span><br><span class="line">&gt; <span class="built_in">wait</span> -n 1</span><br><span class="line">[1]+  Exit 127                &#123; sleep 10; aad; &#125;</span><br><span class="line"></span><br><span class="line">&gt; coproc &#123; sleep 10; aad; &#125;</span><br><span class="line">[1] 558</span><br><span class="line">&gt; <span class="built_in">echo</span> $?</span><br><span class="line">0  <span class="comment"># 这是 coproc 的执行结果</span></span><br><span class="line">&gt; <span class="built_in">jobs</span></span><br><span class="line">[1]+  Exit 127                coproc COPROC &#123; sleep 10; aad; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>管道命令:</strong> 默认情况下, 管道的退出状态取决于管道中最后一条命令的退出状态. 如果设置了 <code>set -o pipefail</code> , 那么只有在管道中的全部命令的退出状态为 <code>0</code> 时, 整个管道的退出状态才为 <code>0</code> , 否则就是最后一个非零的退出状态. 在管道前添加 <code>!</code> 符号可以对整个管道的退出状态取反. <code>bash</code> 中的特殊变量 <code>$PIPESTATUS</code> 以数组的形式存储最近执行的前台管道的退出状态, 要注意的是单个命令也会被记录, 也就是说 <code>${PIPESTATUS[0]}</code> 和 <code>$?</code> 是等价的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管道的退出状态是最后一条命令的退出状态</span></span><br><span class="line">&gt; ps | xxp 2&gt;/dev/null | cat; <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">&gt; <span class="built_in">set</span> -o pipefail </span><br><span class="line">&gt; ps | xxp 2&gt;/dev/null | cat; <span class="built_in">echo</span> $?</span><br><span class="line">127  <span class="comment"># 设置了 pipefail 因此得到最后一个非零退出状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道中每个命令的退出状态被按顺序记录在数组中</span></span><br><span class="line">&gt; easd 2&gt;/dev/null | ls /nou 2&gt;/dev/null | more 2&gt;/dev/null</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;PIPESTATUS[@]&#125;</span></span><br><span class="line">127 2 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不带管道符号的单个命令也会被记录</span></span><br><span class="line">&gt; ping asbasdasd 2&gt;/dev/null; <span class="built_in">echo</span> <span class="variable">$&#123;PIPESTATUS[0]&#125;</span></span><br><span class="line">2</span><br><span class="line">&gt; ping asbasdasd 2&gt;/dev/null; <span class="built_in">echo</span> $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://unix.stackexchange.com/questions/418784/what-is-the-min-and-max-values-of-exit-codes-in-linux" target="_blank" rel="noopener">Exit status range</a></li>
<li><a href="https://linux.die.net/man/1/bash" target="_blank" rel="noopener">Bash man page</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/" data-id="ck8oiuufo0008e6ax6az60w3c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-bash/mechanism/文件描述符与重定向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/bash/mechanism/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" class="article-date">
  <time datetime="2020-04-06T13:38:57.641Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/bash/mechanism/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/">bash/mechanism/文件描述符与重定向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p><code>Linux</code> 操作系统中的文件 <code>I/O</code> 由内核通过文件描述符来完成. 当前进程所追踪的文件描述符以符号链接的形式存放在 <code>/proc/self/fd/</code> 路径下, 其中最特殊的是编号为 <code>0 1 2</code> 的文件描述符, 分别代表 <code>stdin</code> , <code>stdout</code> , <code>stderr</code> . 此外, <code>shell</code> 还可以将 <code>TCP</code> 或 <code>UDP</code> 端口作为文件描述符来对待.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l /dev/std*</span><br><span class="line">lrwxrwxrwx 1 root root 15 Mar 12 18:02 /dev/stderr -&gt; /proc/self/fd/2</span><br><span class="line">lrwxrwxrwx 1 root root 15 Mar 12 18:02 /dev/stdin -&gt; /proc/self/fd/0</span><br><span class="line">lrwxrwxrwx 1 root root 15 Mar 12 18:02 /dev/stdout -&gt; /proc/self/fd/1</span><br><span class="line"></span><br><span class="line">&gt; ls -gGl /proc/self/fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 0 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 2 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 64 Mar 12 21:46 20 -&gt; <span class="string">'socket:[42311]'</span></span><br><span class="line">lr-x------ 1 64 Mar 12 21:46 3 -&gt; /proc/29324/fd</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 对每个进程来说 <code>/proc/self/</code> 下的文件都是独立存在的, 该路径实际上是个符号链接, 指向 <code>/proc/&lt;pid&gt;/</code> . 而从操作系统层面来看, <code>proc</code> 其实是一种特殊的文件系统, 用于给程序提供内核态数据结构的接口, 这个虚拟文件系统默认被挂载在 <code>/proc</code> 路径下, 通过 <code>mount -t</code> 可以将其挂载到其他地方:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount -t &lt;types&gt; &lt;source&gt; &lt;target&gt;</span></span><br><span class="line">&gt; mount -t proc proc /proc</span><br></pre></td></tr></table></figure>

<p>对于 <code>pipe</code> 和 <code>socket</code> , 文件描述符符号链接中会存储文件的类型和 <code>inode</code> , 例如上述例子中的 <code>20 -&gt; &#39;socket:[42311]&#39;</code> , 这说明 <code>20</code> 号文件描述符指向了一个 <code>inode=42311</code> 且已经被删除的 <code>socket</code> . 而对于通过 <code>epoll_create</code> , <code>signalfd</code> , <code>eventfd</code> 等特殊系统调用建立的文件描述符, 其符号链接中会存储 <code>anon_inode:&lt;file-type&gt;</code> 结构的信息, 以 <code>epoll</code> 为例, 其文件描述符中的内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anon_inode:[eventpoll]</span><br></pre></td></tr></table></figure>

<p>对于通过计划任务如: <code>at</code> , <code>cron</code> 等执行的命令, 由于其不像普通命令一样能够继承父 <code>shell</code> 传递来的文件描述符, 因此这类命令的文件描述符一般指向管道或临时文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; at 1140</span><br><span class="line">warning: commands will be executed using /bin/sh</span><br><span class="line">at&gt; ls -l /proc/self/fd/ &gt; /tmp/test.at</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 6 at Fri Mar 13 11:40:00 2020</span><br><span class="line">&gt; cat /tmp/test.at </span><br><span class="line">total 0</span><br><span class="line">lr-x------ 1 remilia remilia 64 Mar 13 11:40 0 -&gt; /var/spool/cron/atjobs/a000060192d99c (deleted)</span><br><span class="line">l-wx------ 1 remilia remilia 64 Mar 13 11:40 1 -&gt; /tmp/test.at</span><br><span class="line">lrwx------ 1 remilia remilia 64 Mar 13 11:40 2 -&gt; /var/spool/cron/atspool/a000060192d99c</span><br><span class="line">lr-x------ 1 remilia remilia 64 Mar 13 11:40 3 -&gt; /proc/19462/fd</span><br></pre></td></tr></table></figure>

<h2 id="重定向执行顺序"><a href="#重定向执行顺序" class="headerlink" title="重定向执行顺序"></a>重定向执行顺序</h2><p>在 <code>shell</code> 中, 我们经常会使用管道与重定向用于控制命令或脚本的输入输出, 这些操作的本质就是更改文件描述符符号链接所指向的文件. 在 <code>shell</code> 中执行一个命令之前会按照如下步骤进行文件描述符操作:</p>
<ul>
<li>如果上一个命令的输出通过管道 <code>|</code> 与当前命令的输入相连, 则把 <code>/proc/&lt;current_process_ID&gt;/fd/0</code> 的指向更新到与 <code>/proc/&lt;previous_process_ID/fd/1</code> 相同指向的匿名管道.</li>
<li>如果当前命令的输出通过管道 <code>|</code> 连接到下一个命令的输入, 则将 <code>/proc/&lt;current_process_ID&gt;/fd/1</code> 的指向更新到另一个匿名管道中.</li>
<li>从左向右按顺序解析所有的重定向符号.<ul>
<li>如果<strong>命令后接</strong>有 <code>N&gt;&amp;M</code> 或 <code>N&lt;&amp;M</code> 则将 <code>/proc/self/fd/N</code> 的输出或输入符号链接指向 <code>/proc/self/fd/M</code> 符号链接指向的目标.</li>
<li>如果有 <code>N &gt; file</code> 或 <code>N &lt; file</code> 则将 <code>/proc/self/fd/N</code> 的输出或输入符号链接指向 <code>file</code> .</li>
<li>如果出现 <code>N&gt;&amp;-</code> 则删除 <code>/proc/self/fd/N</code> 符号链接.</li>
</ul>
</li>
<li>执行命令.</li>
</ul>
<h2 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h2><p><code>shell</code> 中支持的重定向符号如下表所示:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; file</td>
<td>将命令的输入进行重定向到文件</td>
</tr>
<tr>
<td>&gt; file 或 1 &gt; file</td>
<td>将命令的输出重定向到文件, 写入方式为覆盖</td>
</tr>
<tr>
<td>&gt;&gt; file 或 1 &gt;&gt; file</td>
<td>将命令的输出重定向到文件, 写入方式为追加</td>
</tr>
<tr>
<td>2 &gt; file</td>
<td>将命令的标准错误重定向到文件 (覆盖)</td>
</tr>
<tr>
<td>2 &gt;&gt; file</td>
<td>将命令的标准错误重定向到文件 (追加)</td>
</tr>
<tr>
<td>&amp;&gt; file 或 &gt;file 2&gt;&amp;1</td>
<td>将命令的标准输出和标准错误都重定向到一个文件中 (覆盖)</td>
</tr>
<tr>
<td>&amp;&gt;&gt; file 或 &gt;&gt;file 2&gt;&amp;1</td>
<td>将命令的标准输出和标准错误都重定向到一个文件中 (追加)</td>
</tr>
<tr>
<td>&lt;&lt; tag 和 &lt;&lt;- tag</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p><code>/dev/null</code> 是一个特殊的文件, 他会丢弃所有传给他的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; &#x2F;dev&#x2F;null</span><br><span class="line">stderr  # 标准输出被丢弃</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) 2&gt; &#x2F;dev&#x2F;null</span><br><span class="line">stdout  # 标准错误被丢弃</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line"># 标准输出和标准错误都被丢弃</span><br></pre></td></tr></table></figure>

<p>在分析带有重定向的命令时, 要时刻牢记重定向永远是相对命令产生的概念, 因此重定向的结果只与出现的顺序有关:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; c &gt; d echo &quot;abcd&quot; &gt; e</span><br><span class="line"># 从左到右解析重定向符号</span><br><span class="line"># 先把 echo 的 FD1 更新为指向 c</span><br><span class="line"># 再把 echo 的 FD1 更新为指向 d</span><br><span class="line"># 最后把 echo 的 FD1 更新为指向 e</span><br><span class="line">&gt; cat e</span><br><span class="line">abcd</span><br><span class="line">&gt; cat c d</span><br><span class="line"># 没有输出 因为上个命令的输出没有最终指向它们</span><br><span class="line"></span><br><span class="line">&gt; &lt; e grep . &lt; d</span><br><span class="line"># 没有输出因为 d 为空</span><br><span class="line">&gt; &lt; d grep . &lt; e</span><br><span class="line">abcd  # 有输出因为最终是把 grep 的 FD0 更新为指向 e</span><br></pre></td></tr></table></figure>

<p> 再次强调, 重定向符号的顺序会影响最终重定向的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 只重定向标准输出</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log1</span><br><span class="line">stderr</span><br><span class="line">&gt; cat log1</span><br><span class="line">stdout</span><br><span class="line"></span><br><span class="line"># 重定向标准输出和标准错误到同一文件</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &amp;&gt; log2</span><br><span class="line"># 等价于 ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 2&gt;&amp;1</span><br><span class="line"># 等价于 ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 2&gt;&gt;log2</span><br><span class="line">&gt; cat log2</span><br><span class="line">stdout</span><br><span class="line">stderr</span><br><span class="line"></span><br><span class="line"># 错误写法</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 2&gt;log2</span><br><span class="line">&gt; cat log2</span><br><span class="line">stderr  # 标准错误把标准输出给覆盖了</span><br><span class="line"></span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) 2&gt;log2 1&gt;&gt;log2</span><br><span class="line">&gt; cat log2</span><br><span class="line">stderr  # 因为标准输出的写入顺序要优先于标准错误</span><br><span class="line"></span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt; log2 1&gt;&amp;2</span><br><span class="line">stdout  # 先把 FD1 指向 log2, 再把 FD1 指向标准错误</span><br><span class="line">stderr</span><br><span class="line">&gt; cat log2  # 因此 log2 里什么也没有</span><br></pre></td></tr></table></figure>

<h2 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号"></a>管道符号</h2><p>管道是进程间通讯的经典方法, 在 <code>shell</code> 中, 我们使用匿名管道符号 <code>|</code> 将前一个进程的 <code>stdout</code> 与后一个进程的 <code>stdin</code> 连接. 如下例, 我们先用 <code>cat</code> 将文件合并, 然后将其传递给后续命令进行处理, 这样就构建了处理流水线:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat $filename1 $filename2 | grep $search_word</span><br><span class="line">&gt; cat f&#123;1,2,3,2,3,1,1&#125; | sort -r | uniq  </span><br><span class="line">3  </span><br><span class="line">2  </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>shell</code> 中支持的管道符号如下表所示:<br>| 符号 | 说明 |<br>| – | – |<br>| cmd1 | cmd2  | 将 <code>cmd1</code> 的标准输出和 <code>cmd2</code> 的标准输入指向 <code>pipe</code> |<br>| cmd1 |&amp; cmd2  | 现将 <code>cmd1</code> 的标准输出和 <code>cmd2</code> 的标准输入指向 <code>pipe</code> , 再将 <code>cmd1</code> 的标准错误指向到当前标准输出的指向, 等价于 <code>cmd1 2&gt;&amp;1 | cmd2</code> .|</p>
<p>管道默认是将左侧的标准输出和右侧的标准输入连接到同一个 <code>pipe</code> 文件上, 如果我们想把标准错误也传递给右侧可以按照如下方式操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 传递 stdin 与 stderr</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) |&amp; awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line"># 等价于( echo stdout; echo stderr &gt;&amp;2 ) 2&gt;&amp;1 | awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line">From pipe: stdout</span><br><span class="line">From pipe: stderr</span><br><span class="line"></span><br><span class="line"># 只传递 stderr</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null | awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line">From pipe: stderr</span><br><span class="line"></span><br><span class="line">1. 首先处理管道, 将&quot;command FD 1&quot; 和 &quot;grep FD 0&quot;都指向管道</span><br><span class="line">2. 将&quot;command FD2&quot;指向&quot;command FD1&quot;当前的指向 (也就是管道)</span><br><span class="line">3. 将&quot;command FD1&quot;指向 &#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line"># 错误写法</span><br><span class="line">&gt; ( echo stdout; echo stderr &gt;&amp;2 ) &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 | awk &#39;&#123; printf &quot;From pipe: %s\n&quot;, $0 &#125;&#39;</span><br><span class="line"></span><br><span class="line">1.  首先处理管道, 将&quot;command FD 1&quot; 和 &quot;grep FD 0&quot;都指向管道</span><br><span class="line">2.  将&quot;command FD 1&quot;指向 &#x2F;dev&#x2F;null</span><br><span class="line">3.  将&quot;command FD 2&quot;指向&quot;command FD 1&quot;当前的指向 (&#x2F;dev&#x2F;null)</span><br><span class="line">4. 管道都没有输入端, 自然不会传递任何数据给 grep</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[warning]注意: 要注意区分管道符号与重定向符号. <code>|</code> 左边的命令应该有标准输出, 其右边的命令应该接受标准输入; 但重定向符号的右侧只能是文件. 此外, 管道触发两个 <code>sub shell</code> 执行 <code>|</code> 两边的程序；而重定向是在一个进程内执行.</p>
</blockquote>
<p>由于管道两侧的命令会放到 <code>sub shell</code> 中执行, 因此不能改变父 <code>shell</code> 中的变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; var&#x3D;&quot;init_value&quot;</span><br><span class="line">&gt; echo &quot;new_value&quot; | read var</span><br><span class="line">&gt; echo &quot;var &#x3D; $var&quot;</span><br><span class="line">var &#x3D; init_value</span><br></pre></td></tr></table></figure>

<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>使用 <code>|</code> 建立的管道是匿名管道, 只在父进程与子进程之间起作用. 如果我们需要复杂的进程通信(如: 跨终端通信), 需要使用 <code>mkfifo</code> 创建命名管道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkfifo &#x2F;tmp&#x2F;fifo1</span><br><span class="line"># mknod &#x2F;tmp&#x2F;fifo1 p</span><br><span class="line">&gt; file &#x2F;tmp&#x2F;fifo1</span><br><span class="line">&#x2F;tmp&#x2F;fifo1: fifo (named pipe)</span><br><span class="line">&gt; ls -lF &#x2F;tmp&#x2F;fifo1  # -F 选项会在结尾加管道符号</span><br><span class="line">prw-rw-r-- 1 remilia remilia 0 Mar 15 19:18 &#x2F;tmp&#x2F;fifo1|</span><br></pre></td></tr></table></figure>

<p>管道的读写遵照先进先出原则, 其内容驻留在内存中而不是被写到硬盘上, 数据内容只有在输入输出端都打开时才会传送. <code>FIFO</code> 具有以下特点:</p>
<ol>
<li>当写进程向管道中写数据的时候，如果没有进程读取这些数据，写进程会堵塞</li>
<li>当读取管道中的数据的时候，如果没有数据，读取进程会被堵塞</li>
<li>当写进程堵塞的时候，有读进程读取数据，那么写进程恢复正常</li>
<li>当读进程堵塞的时候，如果写进程写了数据，那么读进程会读取数据，然后正常执行后面的代码</li>
</ol>
<p>下面是一个循环读取 <code>FIFO</code> 内容的脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">pipe&#x3D;&#x2F;tmp&#x2F;fifo1</span><br><span class="line"></span><br><span class="line">trap &quot;rm -f $pipe&quot; EXIT</span><br><span class="line"></span><br><span class="line">if [[ ! -p $pipe ]]; then</span><br><span class="line">    mkfifo $pipe</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 不加外面这层则读到 end-of-stream 就退出</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    while read line</span><br><span class="line">    do</span><br><span class="line">        if [[ &quot;$line&quot; &#x3D;&#x3D; &#39;quit&#39; ]]; then</span><br><span class="line">            break</span><br><span class="line">        else</span><br><span class="line">            echo $line</span><br><span class="line">        fi</span><br><span class="line">    done &lt; $pipe</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Stop reader....&quot;</span><br></pre></td></tr></table></figure>

<h2 id="自定义文件描述符"><a href="#自定义文件描述符" class="headerlink" title="自定义文件描述符"></a>自定义文件描述符</h2><p>我们可以通过 <code>exec</code> 命令自定义文件描述符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># exec fdN&gt; file</span><br><span class="line">&gt; exec 6&gt; file  # 把文件描述符 6 分配给 file 只写</span><br><span class="line">&gt; echo &quot;line1&quot; &gt;&amp; 4</span><br><span class="line">&gt; cat file</span><br><span class="line">line1</span><br><span class="line"></span><br><span class="line"># exec fdN&lt; file</span><br><span class="line">&gt; exec 7&lt; file # 把文件描述符 7 分配给 file 只读</span><br><span class="line">&gt; echo &quot;line2&quot; &gt; file</span><br><span class="line">&gt; cat &lt;&amp; 7</span><br><span class="line">line2</span><br><span class="line"></span><br><span class="line"># exec fdN&lt;&gt; file</span><br><span class="line">&gt; exec 8&lt;&gt; file # 读写 多用于fifo</span><br><span class="line"></span><br><span class="line"># read -u 表示从文件描述符读取</span><br><span class="line">&gt; read -u 7 line; echo $line</span><br><span class="line">line2</span><br></pre></td></tr></table></figure>

<p>我们可以在脚本中将标准输入描述符暂存, 从而实现让脚本能够自由切换输入为文件或终端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CONFIG&#x3D;&#x2F;var&#x2F;tmp&#x2F;sysconfig.out</span><br><span class="line"></span><br><span class="line"># 暂存标准输入描述符</span><br><span class="line">exec 7&lt;&amp;0</span><br><span class="line"></span><br><span class="line"># 切换输入为文件</span><br><span class="line">exec &lt; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">read rootpasswd</span><br><span class="line">echo $rootpasswd &gt;&gt; &quot;$CONFIG&quot;</span><br><span class="line"></span><br><span class="line"># 恢复标准输入 并删除暂存描述符</span><br><span class="line">exec 0&lt;&amp;7 7&lt;&amp;-</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>exec fd&lt;&amp;-</code> 关闭一个文件描述符, 例如我们可以将标准输出打印到屏幕的同时将标准错误传递到管道右侧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat listdirs.sh</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">INPUTDIR&#x3D;&quot;$1&quot;</span><br><span class="line"></span><br><span class="line"># 文件描述符 6 指向标准输出</span><br><span class="line">exec 6&gt;&amp;1</span><br><span class="line"></span><br><span class="line"># ls 的 FD1 和 awk 的 FD0 都指向管道</span><br><span class="line"># 把 ls 的 FD2 指向 FD1 当前的指向, 也就是管道</span><br><span class="line"># 把 ls 的 FD1 指向 FD6 当前的指向, 也就是标准输出</span><br><span class="line"># 管道两侧的 subshell 会继承父 shell 的文件描述符</span><br><span class="line"># 关闭 ls 的 FD6</span><br><span class="line"># 关闭 awk 的 FD6</span><br><span class="line">ls &quot;$INPUTDIR&quot;&#x2F;* 2&gt;&amp;1 &gt;&amp;6 6&gt;&amp;- | awk -F&quot;:&quot; &#39;&#123;print &quot;ERROR: &quot; $2&#125;&#39; 6&gt;&amp;-</span><br><span class="line"></span><br><span class="line"># 关闭当前 shell 的文件描述符</span><br><span class="line">exec 6&gt;&amp;-</span><br><span class="line"></span><br><span class="line">&gt; bash listdirs.sh &#x2F;root</span><br><span class="line">ERROR:  cannot access &#39;&#x2F;root&#x2F;*&#39;</span><br></pre></td></tr></table></figure>

<p>如果在文件描述符未被释放的情况下删除原文件, 可以通过拷贝描述符的方式恢复文件数据(拷贝后的文件与原文件 <code>inode</code> 不同):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; touch file1</span><br><span class="line">&gt; exec 6&gt; file1</span><br><span class="line">&gt; ll &#x2F;proc&#x2F;$&#x2F;fd&#x2F;6</span><br><span class="line">lrwx------ 1 remilia remilia 64 Mar 15 18:58 6 -&gt; &#x2F;home&#x2F;remilia&#x2F;file1</span><br><span class="line">&gt; echo &quot;abcd&quot; &gt;&amp; 6</span><br><span class="line">&gt; cat file1</span><br><span class="line">abcd</span><br><span class="line">&gt; cat &#x2F;proc&#x2F;$&#x2F;fd&#x2F;6</span><br><span class="line">abcd</span><br><span class="line">&gt; rm file1</span><br><span class="line">&gt; lrwx------ 1 remilia remilia 64 Mar 15 18:58 6 -&gt; &#39;&#x2F;home&#x2F;remilia&#x2F;file1 (deleted)&#39;</span><br><span class="line">&gt; cp &#x2F;proc&#x2F;$&#x2F;fd&#x2F;6 ~&#x2F;file1</span><br><span class="line">&gt; cat file1</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>

<h2 id="嵌入文档"><a href="#嵌入文档" class="headerlink" title="嵌入文档"></a>嵌入文档</h2><p>嵌入文档 (Here Document) 是一种特殊的重定向方式，它的基本的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br><span class="line"></span><br><span class="line"># 加个 - 也可以</span><br><span class="line">command &lt;&lt;- delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>

<p>它的作用是将两个 <code>delimiter</code> 之间的内容 <code>document</code> 作为输入传递给 <code>command</code> . 注意：</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。</li>
</ul>
<p>下面的例子，通过 <code>wc -l</code> 命令计算 <code>document</code> 的行数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; wc -l &lt;&lt; EOF</span><br><span class="line">&gt; This is a simple lookup program</span><br><span class="line">&gt; for good (and bad) restaurants</span><br><span class="line">&gt; in Cape Town.</span><br><span class="line">&gt; EOF</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>也可以 将 Here Document 用在脚本中，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">wc -w &lt;&lt;EOF</span><br><span class="line">This is a test.</span><br><span class="line">Apple juice.</span><br><span class="line">100% fruit juice and no added sugar, colour or preservative.</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/06/bash/mechanism/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" data-id="ck8oiuufp0009e6ax8y1hdnw4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">bash/mechanism/信号处理</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A7%8D%E7%B1%BB/">bash/mechanism/命令的种类</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/">bash/mechanism/命令的执行方式</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/">bash/mechanism/自动补全</a>
          </li>
        
          <li>
            <a href="/2020/04/06/bash/mechanism/%E5%AD%90shell/">bash/mechanism/子shell</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>