---

layout:     post
title:      高级数据结构（三）
subtitle:   位运算与哈希
date:       2020-02-03 10:00:00
author:     "Remilia Scarlet"
header-img: "2020/06/06/t6XpBn.jpg"
catalog: true
mathjax: true
tags:
    - 数据结构
---

# 位运算

位运算是什么, 原理

bit byte 区别

速度对比

## 位图结构

原理, 一个 long int 表示几位

大数据去重

## 在数据库中的应用

## 在select中的应用

存储fd的位图结构

遍历数据结构

# 哈希表

[哈希表（Hash Table）](https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869)是经典的[键值存储（Key-Value）](https://img.xileso.top/baike-%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8)数据结构, 其特点是随机访问时需要先通过**哈希函数**计算每个键所对应的哈希值, 再通过**索引映射函数**得到其在哈希表中的真实索引, 最后根据索引得到对应的值.

令哈希函数为$hash()$, 索引映射函数为$index()$, 则在给定的哈希表$T$中, 得到键$k$所对应的值$v$的过程可以描述如下:

\begin{equation}
k_{hash} = hash(k)
\end{equation}

\begin{equation}
k_{index} = index(k_{hash})
\end{equation}

\begin{equation}
T[k] = T.get(k_{index}) = v
\end{equation}

其中, $index()$的实现方式与哈希表的结构和**哈希冲突**的解决方法有关. 以链地址形式的哈希表为例, $index()$首先会对$k_{hash}$以数组长度取模得到对应链表的首地址, 然后通过遍历该链表得到真实值.

哈希表的设计思路是**空间换时间**, 令$T$为节点数量为$s$的哈希表, 设其中非空节点的数量为$m$, 则**负载因子（Load Factor）**可按照如下公式计算:

\begin{equation}
F_{load} = m/s
\end{equation}

相比于空间利用率接近100%的[红黑树](https://zhuanlan.zhihu.com/p/31805309)来说, 哈希表会在负载因子大于阈值时进行扩容并重新映射所有数据, 这样能保证插入和查找数据的时间复杂度尽不会随着哈希冲突出现的次数而显著增加. 设计良好的哈希函数能够让哈希表以$O(1)$时间复杂度实现对数据的查找, 但如果哈希函数无法有效地让键离散化, 那么严重的哈希冲突会导致哈希表的查找时间复杂度退化为$O(n)$的线性表或$O(logn)$的红黑树.

## 常用哈希函数

根据[PlanetMath](https://planetmath.org/goodhashtableprimes)中的说法

The following is such a list. It has the properties that:

1.
each number in the list is prime

2.
each number is slightly less than twice the size of the previous

3.
each number is as far as possible from the nearest two powers of two

计算效率与结果的离散程度是评价哈希函数的最重要标准.

好的哈希函数能够让映射的结果尽量分散

最近看到mysql的hash表，发现一个特点。
当hash表满的时候，hash表size总是扩展成一个素数

假设hash表大小为size，这是一个合数，即有size=a*n。当有hash值为hashcode，且hashcode = b*n.
则hashcode取模之后为
hashcode = hashcode%size = hashcode - (hashcode / size) *size = hashcode - (b/a)* size
因为a是固定的，那么上面的hashcode的取值只有b种可能，这样显然会增加冲突的概率。

函数设计得好就不用对质数取模, JDK用的算

注意: 每次查找和插入都需要通过哈希函数计算哈希值, 因此最好加缓存

## 哈希冲突解决方案

分离链表: JDK, redis, Python中的实现方案. 实现简单, 占空间, 数组, 连续地址空间, 随机寻址容易, 插入删除费劲; 链表地址不连续, 随机寻址费劲, 插入删除容易; 链表遍历的时间复杂度O(n), 红黑树遍历时间复杂度O(logn)

注意: 算法到伦理提到过, 当n非常大时, 任意底数的logn只相差常数倍, O(logn)已经可以表达所有底数的对数

开放定址法：
开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。尽管写入逻辑简单, 但读取时逻辑及其复杂, 唯一的优点是节省空间

链地址法
将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。

再哈希法
当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。

建立公共溢出区
将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

## 哈希表结构优化

Python3.7版本之后的字典结构要优于普通哈希表, 因为他的索引是整数, 哈希值和kv存在链表里, 只需要对整数数组做rehash, 因此数据量特别大的时候效率也不会明显降低

实现字典

JDK的优化 完全随即hash的情况下, 每个节点所对应的list的长度服从泊松分布, 大于8时概率为0.0000006, 转换为红黑树, 节省空间

求hash时用位运算加速

负载因子, 为什么选0.75, 最优解是ln2也就是0.693

令事件A为节点$Q$被插入数据, 则在完全随机生成哈希值的情况下, 每次向$T$中添加数据时事件A发生的概率为:

\begin{equation}
P_A=\frac{1}{s}
\end{equation}

现在向$T$中添加$n$个数据, 用$X$表示这$n$次独立重复的实验中事件A发生的次数, 显然服从[二项分布](https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83):

\begin{equation}
P_{X=k} = C(n, k)P_A^k(1-P_A)^{n-k}
\end{equation}

那么$n$次实验中事件A恰好发生0次的概率为:

\begin{equation}
P_{X=0} = (\frac{s-1}{s})^{n}
\end{equation}

这个对于节点$Q$成立的结论可以推广到$T$中的所有节点, 为了保证

当添加数据的数量小于$log(2)/log(s/(s - 1))$时, 满足$P_{X=0}>0.5$来保证CPU分支预测时缓存的命中率, 也就是让不发生哈希冲突的概率大于发生

因此代入

现在问题就转化为求

由于CPU中分支预测的阈值为0.5, 因此

每个节点被插入的概率为$P=\frac{1}{s}$

则$n$次, 事件A恰好发生0次的概率:

每次插入新键时每个节点

每个节点发生哈希冲突的概率服从二项分布, 而每个节点发生哈希冲突的次数服从泊松分布. 那么我们

\begin{equation}
P(0) = C(n, 0) * 1/s
\end{equation}

相比于空间利用率

是一种空间换时间的数据结构, 能够有效查找数据

# 一致性哈希

应用场景: 缓存集群的负载均衡

例如: 3千万张图片, N台缓存服务器组成集群

server_num = hash(img_name) % N

添加服务器, N变化时, 同一张图片的server_num的值会变化, 所有的缓存都要重新配置

设计一种动态伸缩算法

## 哈希环与虚拟节点

理想情况 均匀分布 映射到2^32哈希环中

图1:

但实际上分布不均匀 哈希偏置
而且某台服务器突然宕机会导致下一个节点承受双倍流量
所以引入虚拟节点

图2:

## 实现细节

用python模拟实现负载均衡
map 红黑树 保证插入有序

寻找大于当前hash值的第一个节点

注意处理边界

# 参考内容
