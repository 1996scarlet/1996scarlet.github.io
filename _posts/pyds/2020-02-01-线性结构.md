---

layout:     post
title:      深入理解数据结构（一）
subtitle:   线性结构及其应用
date:       2020-02-01 10:00:00
author:     "Remilia Scarlet"
header-img: "2020/06/06/t6XpBn.jpg"
catalog: true
mathjax: true
tags:
    - 数据结构
---

# 序列型结构

**序列（Sequence）**是**存储有序数据的线性结构**. Python内置的序列类型包括以字符串（str）、数组（array）和内存视图（memoryview）为代表的, 只能存储相同数据类型的**扁平序列**; 以及更常用的列表（list）、元组（tuple）、双端队列（deque）等能够存储不同类型数据的**容器序列**.

扁平序列类似于C语言中的数组, 其特点是在连续的内存空间中直接存储数据的**值**, 因此适用于紧凑地存储基本数据类型; 而容器序列中存储的却是对象的**引用**, 因此能够在不用打包和拆包的前提下存储不同类型的数据, 但代价是在访问数据时需要进行二次寻址.

而根据是否能够修改所存储的内容又可以将序列分为**可变（Mutable）**和**不可变（Immutable）**两类. Python在解释器层面限制了对元组、字符串和字节串（bytes）等不可变序列中元素的修改, 而像列表这种可变序列就没有这种限制. 但不可变序列的好处在于能够通过`hash`函数计算其哈希值, 因此可以被用于充当字典的键或者存储在集合中.

大部分序列类型都继承自抽象基类[collections.abc.Sequence](https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence), 因此普遍支持如下表所示的通用操作:

|操作|结果|
|----|----|
|x in s|如果 s 中的某项等于 x 则结果为 True, 否则为 False|
|x not in s|如果 s 中的某项等于 x 则结果为 False, 否则为 True|
|s + t|s 与 t 相拼接, 对不可变序列操作则会创建新对象|
|s \* n 或 n \* s|相当于 s 与自身进行 n 次拼接|
|s[i]|s 的第 i 项, 起始为 0|
|s[i:j]|s 从 i 到 j 的切片, 索引支持负数|
|s[i:j:k]|s 从 i 到 j 步长为 k 的切片, 支持负数, 例如: s[::-1]为反转序列|
|len(s)|s 的长度|
|min(s)|s 的最小项|
|max(s)|s 的最大项|
|s.index(x[, i[, j]])|x 在 s 中首次出现项的索引号（索引号在 i 或其后且在 j 之前）|
|s.count(x)|x 在 s 中出现的总次数|

但也有例外, 像区间（range）这类的迭代器序列就不支持直接拼接. 此外, 相同类型的序列之间也支持字典序比较, 只有在长度以及对应元素的值相同时, 两个序列才被认为相等.

## 列表

列表是内置的可变容器序列, 对每个列表对象来说, 其内部存储的是对应元素的引用, 例如:

```python
vtuber = ['mea', 'aqua', 'alice']

mea, aqua, alice = 'mea', 'aqua', 'alice'
vup = [mea, aqua, alice]

# True 两个列表中的元素指向的是同一段内存 都是引用
print(all(map(lambda x, y: x is y, vtuber, vup)))

# True 列表中对应元素的值相同
print(vtuber == vup)

# False 尽管容器内元素引用相同 但却是不同的列表对象
print(vtuber is vup)
```

尽管在初始化`vtuber`列表时直接使用字符串对象作为输入, 但在列表中却只记录了这些对象的引用, 因此其内部存储结构与通过传入字符串对象引用而构造的`vup`列表相同, 这一结论可以通过`map`函数的输出结果验证. 列表中可以存储任意类型, 这类似于C语言中的`void*`指针数组. 在访问列表中的元素时, 首先需要通过列表名访问列表的实际内存地址, 然后通过其中记录的元素引用获得元素的内容, 这个过程就是**二次寻址**.

|列表变量名|列表中的元素引用|元素引用|元素内容|
|-----|----|----|----|
|     |vtuber[0]|mea| 'mea'|
|vtuber|vtuber[1]|aqua|'aqua'|
|      |vtuber[2]|alice|'alice'|

事实上在Python中, 一切可交互的实体都是对象, 而对象的名字就是其引用. 在创建变量时, 必须让其指向某个已经创建好的对象, 例如:

```python
r0, r1 = range(5), range(5)
# 二者指向了不同的对象
print(r0 is r1)  # False

r2 = r0
# 二者是相同对象的引用
print(r0 is r2)  # True

v0, v1 = 3.14, 3.14
# 数字和某些字符串会被小数据池缓存
print(v0 is v1)  # True
```

Python在设计时考虑到了频繁创建相同对象所带来的性能损耗, 因此提供了针对数字和部分字符串的缓存优化机制, 这部分内容可以参考[小数据池与缓存](https://www.cnblogs.com/jin-xin/articles/9439483.html).

列表的内存分配方式为运行时动态分配, 这类似于C++中的向量（vector）. 初始分配给列表的内存是连续的, 当内部元素数量饱和时就扩容50%左右. 默认情况下, 列表会在当前所处的**堆空间**后方继续申请连续的内存, 如果这段空间被占用, 则会新开辟一段连续的内存并迁移当前数据.

在数据量很大时, 通过**列表推导式（list comprehension）**构建列表的速度要[远超](https://stackoverflow.com/questions/16907109/python-list-comprehension-vs-for)直接使用外部循环的方法, 并且带有`if`代码块的列表推导式能够在一定程度上替换高阶函数`filter`. 例如, 获得所有名字长度大于5的姓名列表:

```python
vtubers = ['miko', 'watame', 'fubuki', 'pekora']
print([name for name in vtubers if len(name) > 5])

# 也可以替换为 None
print([name if len(name) > 5 else None for name in vtubers])
```

列表推导式的优势在于代码简洁且可读性强, 但要注意的是, 列表推导式只适合于生成新的列表, 而不适用于在原有列表中进行修改. 为了防止被滥用, 建议在逻辑较为复杂时使用函数简化代码, 或者直接用外部循环重写. 例如, 通过列表推导式配合外部循环构造[幂集](https://leetcode-cn.com/problems/power-set-lcci/):

```python
res = [[]]

for num in range(3):
    # 每次拼接当前数字到列表中的所有元素
    res += [r + [num] for r in res]
```

和其他可变序列一样, 列表中提供了如下表所示的序列编辑操作:

|运算|结果|
|----|----|
|s[i] = x|将 s 的第 i 项替换为 x|
|s[i:j] = t|将 s 从 i 到 j 的切片替换为可迭代对象 t 的内容|
|del s[i:j]|等同于 s[i:j] = []|
|s[i:j:k] = t|将 s[i:j:k] 的元素替换为 t 的元素|
|del s[i:j:k]|列表中移除 s[i:j:k] 的元素|
|s.append(x)|将 x 添加到序列的末尾 (等同于 s[len(s):len(s)] = [x])|
|s.clear()|从 s 中移除所有项 (等同于 del s[:])|
|s.copy()|创建 s 的浅拷贝 (等同于 s[:])|
|s.extend(t) 或 s += t|用 t 的内容扩展 s (基本上等同于 s[len(s):len(s)] = t)|
|s *= n|使用 s 的内容重复 n 次来对其进行更新|
|s.insert(i, x)|在由 i 给出的索引位置将 x 插入 s (等同于 s[i:i] = [x])|
|s.pop([i])|提取在 i 位置上的项，并将其从 s 中移除|
|s.remove(x)|删除 s 中第一个 s[i] 等于 x 的项目|
|s.reverse()|就地将列表中的元素逆序|

熟练使用这些API不仅能显著提升开发效率, 还可以方便地实现其他线性数据结构. 例如: 通过`insert`和`pop`可以实现先入先出的队列, 但受限于列表的内存结构, 在头部插入数据时会导致全部数据向后移动, 因此更推荐使用对双端操作做了特殊优化的`collections.deque`队列, 更多内容请参考[栈与队列]().

## 元组

元组是内置的不可变容器序列, 其构造方法类似于列表, 但要注意区分**生成器表达式（generator expression）**与定义元组的方式.

```python
# 定义一个元组
('paryi', 'mea', '2018-06-28')

# 元组构造函数接收可迭代对象
tuple(x for x in range(5))

# 这是生成器表达式 不是元组
(x for x in range(5))
```

元组中元素不变的性质让其适合于存放字段,

这个过程就是元组的拆包与打包.

值得注意的是, 函数的默认参数和可变参数是以元组的形式传递, 而关键字参数则是以字典的方式传递

传入函数的参数也是以元组的形式, python中的函数支持动态参数, 因此不需要重载

```python

```

: 利用zip解包转置矩阵

```python
list(zip(*matrix))
```

命名元组

特殊的range

## 数组

在本文中, 我们将**数组（Array）**定义为在**连续**地址空间中存储**相同**数据类型的结构. 令数组$a$的首地址为$p_0$, 存储的每个元素所占用的空间为$s$, 则通过索引$i$就可以计算出第$i$个元素的地址$p_i$:

\begin{equation}
address(a[i]) = p_i = p_0 + i * s
\end{equation}

这使得数组能够以$O(1)$的时间复杂度轻松应对需要频繁通过索引来对元素进行**随机访问**的应用场景, 例如: 二分查找、快速排序、哈希表等. 但在使用数组前必须要根据数据类型$T$及数量$N$来计算需要初始化的空间$S$:

\begin{equation}
S = sizeof(T) \* N = s \* N
\end{equation}

在C语言中, 使用变量类型加数组名的方式定义的数组会被分配到**栈空间**, 由操作系统管理其生命周期; 而使用数组指针加运行时内存分配方式定义的数组会被分配到**堆空间**, 在不用时需要手动释放.

```c
N = 1024;  // C99 支持使用变量初始化数组

// 在编译阶段能够确定大小的数组会被分配到栈上
int arr[N] = {0};

// 数组指针指向 malloc 系统调用动态分配的堆内存
int  *parr = (int*)malloc(sizeof(int) * N);
free(parr);  // 释放
```

值得注意的是, 在数组中**插入**或**删除**元素时, 为了保证其他元素仍以紧凑且连续的方式存储在内存中, 需要移动对所操作元素的后续所有元素, 因此这些操作的时间复杂度为$O(n)$.

array标准库
详见[标准库文档](https://docs.python.org/zh-cn/3/library/array.html)

# 字符串

**字符串（String）**是由任意数量的字符所构成的有限序列. 在现代高级编程语言中, 字符串一般被当做存储文本的数据结构, 可记为:

\begin{equation}
string=c_0c_1c_2...c_{n-1}
\end{equation}

在C语言中并不存在原生的字符串类型, 因此采用以'\0'为结束标记的字符型数组作为替代. 这种实现方式的优点在于能够通过下标索引直接原地修改字符串的内容, 但缺点在于无法将字符串所包含的内容作为哈希表的键, 只能使用字符串的首地址作为替代. 值得注意的是, `char`类型只占用1个字节, 因此只能表示ASCII字符; 而`wchar`类型的字符占用2个字节, 因此可以存储Unicode编码的字符.

而在Python中, 内置的字符串类型`str`被定义为存储**不可变序列**的数据结构, 这意味着字符串将被当作常量处理, 任何修改字符串的方法都会生成新的字符串常量:

```python
>>> s = "a"
>>> id0 = id(s)
>>> s+="b"
# 字符串是常量 因此会生成新的字符串 "ab"
>>> s
'ab'
>>> id1 = id(s)
>>> id0==id1  # s指向了新生成的字符串对象
False
>>> s[1]="c"  # 常量不支持直接修改
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

尽管基于**引用计数（Reference Counting）**的垃圾回收机制可以保证拼接过程中丢弃的字符串常量不会造成内存泄漏, 但生成与销毁字符串的成本却不容小觑. 例如, 在拼接$10^7$次的前提下, 使用`join()`方法要比直接使用加号快20%左右.

```python
def func_timer(func):
    def insider(*args):
        st = time.perf_counter()
        func(*args)
        print(time.perf_counter() - st)
    return insider

@func_timer
def str_add(base, adder, times):
    for i in range(times):
        base += adder

@func_timer
def join_add(base, adder, times):
    base.join(adder for i in range(times))

A, N = "nginx" * 16, 10**7

# 0.7467752849988756
str_add("", A, N)
# 0.6037130299991986
join_add("", A, N)
```

但要注意的是, 由于CPython解释器具有**常数折叠（Constant Folding）**机制, 少量的静态字符串拼接操作会在转换为字节码时自动优化为单个字符串常量, 因此在实际使用中可能感受不到[各种拼接方式](https://www.jiqizhixin.com/articles/2018-11-01-3)之间的性能差异.

如果拼接 str 对象，你可以构建一个列表并在最后使用 str.join() 或是写入一个 io.StringIO 实例并在结束时获取它的值

在编程语言中,字符串往往由特定字符集内有限的字符组合而成,根据其特点,对字符串的 操作 可以归结为以下几类：

字符串的比较、连接操作（不同编程语言实现方式有所不同）；

涉及子串的操作,比如前缀,后缀等；

字符串间的匹配操作,如 KMP 算法、BM 算法等。

## 双指针

对撞指针: 反转字符串, 分割数组, 求和ii, 验证回文串isalnum()
快慢指针:

# 链表

内存模型

与数组的区别 适用场景区别

数组: 地址连续 支持随机访问 扩展性差 插入删除成本高

链表: 地址分散 不支持随机访问 访问需要遍历 不支持二分法 扩展性强 插入删除成本低

与数组不同,我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素,我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费 O(N) 时间,其中 N 是链表的长度。

例如,在上面的示例中,头结点是 23。访问第 3 个结点的唯一方法是使用头结点中的“next”字段到达第 2 个结点（结点 6）; 然后使用结点 6 的“next”字段,我们能够访问第 3 个结点。

你可能想知道为什么链表很有用,尽管它在通过索引访问数据时（与数组相比）具有如此糟糕的性能。 在接下来的两篇文章中,我们将介绍插入和删除操作,你将了解到链表的好处。

## 单向链表

判断环

## 双向链表

LRU cache

# 二分查找

必须有序

关键属性

二分查找的最基础和最基本的形式。
查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。
不需要后处理,因为每一步中,你都在检查是否找到了元素。如果到达末尾,则知道未找到该元素。

区分语法

初始条件：left = 0, right = length-1
终止：left > right
向左查找：right = mid-1
向右查找：left = mid+1

```python
def binarySearch(nums, target):
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```

抽象二分查找
[寻找重复数](https://leetcode-cn.com/explore/learn/card/binary-search/215/more-practices-ii/858/)

[三种模板](https://leetcode-cn.com/explore/learn/card/binary-search/212/template-analysis/847/)

`bisect`模块

## 多维数组

二维数组是一种结构较为特殊的数组,只是将数组中的每个元素变成了一维数组, 所以二维数组的本质上仍然是一个一维数组,内部的一维数组仍然从索引 0 开始,我们可以将它看作一个矩阵,并处理矩阵的相关问题。
这个定义可以推广多

## 高性能向量计算

注意: 为了防止概念混淆, 本文给出以下定义.

标量：很简单,就是一个数,1,2,5,108等等
向量：[1,2],[1,2,3],[1,2,3,4],[3,5,67,·······,n]都是向量
矩阵：[[1,3],[3,5]],[[1,2,3],[2,3,4],[3,4,5]],[[4,5,6,7,8],[3,4,7,8,9],[2,11,34,56,18]]是矩阵
张量：[[[1,2],[3,4]],[[1,2],[3,4]]]

# 位图

# 案例1: 动态数组的内存分配

# 案例2: 子序列与子串问题

# 案例3: 位运算与位图

# 参考内容
