---

layout:     post
title:      深入理解数据结构（一）
subtitle:   线性结构及其应用
date:       2020-02-01 10:00:00
author:     "Remilia Scarlet"
header-img: "2020/06/06/t6XpBn.jpg"
catalog: true
mathjax: true
tags:
    - 数据结构
---

# 序列型结构

**序列（Sequence）**是**存储有序数据的线性结构**. Python内置的序列类型包括以字符串（str）、数组（array）和内存视图（memoryview）为代表的, 只能存储相同数据类型的**扁平序列**; 以及更常用的列表（list）、元组（tuple）、双端队列（deque）等能够存储不同类型数据的**容器序列**.

扁平序列类似于C语言中的数组, 其特点是在连续的内存空间中直接存储数据的**值**, 因此适用于紧凑地存储基本数据类型; 而容器序列中存储的却是对象的**引用**, 因此能够在不用打包和拆包的前提下存储不同类型的数据, 但代价是在访问数据时需要进行二次寻址.

而根据是否能够修改所存储的内容又可以将序列分为**可变（Mutable）**和**不可变（Immutable）**两类. Python中的元组、字符串和字节串（bytes）就是典型的不可变序列, 在解释器层面限制了对内部元素的修改, 而像列表这类的可变序列就没有这种限制.

## 列表

list中存储的都是对象的地址, 因此可以存储任意类型, 类似于`void*p`指针数组

list其实是动态数组, 其初始内存分布是连续的, 达到一定数量就扩容, 这点类似于C++中的vector, 都是扩充为当前的两倍

动态数组: 可以存储任意类型的数据, 数组大小会在运行中根据需要自动扩容, 有原地扩容和重新拷贝两种方式, 因此一般存储在堆上
动态数组的内存分配

## 元组

不可变序列

元组拆包与打包

命名元组

## 数组

在本文中, 我们将**数组（Array）**定义为在**连续**地址空间中存储**相同**数据类型的结构. 令数组$a$的首地址为$p_0$, 存储的每个元素所占用的空间为$s$, 则通过索引$i$就可以计算出第$i$个元素的地址$p_i$:

\begin{equation}
address(a[i]) = p_i = p_0 + i * s
\end{equation}

这使得数组能够以$O(1)$的时间复杂度轻松应对需要频繁通过索引来对元素进行**随机访问**的应用场景, 例如: 二分查找、快速排序、哈希表等. 但在使用数组前必须要根据数据类型$T$及数量$N$来计算需要初始化的空间$S$:

\begin{equation}
S = sizeof(T) \* N = s \* N
\end{equation}

在C语言中, 使用变量类型加数组名的方式定义的数组会被分配到**栈空间**, 由操作系统管理其生命周期; 而使用数组指针加运行时内存分配方式定义的数组会被分配到**堆空间**, 在不用时需要手动释放.

```c
N = 1024;  // C99 支持使用变量初始化数组

// 在编译阶段能够确定大小的数组会被分配到栈上
int arr[N] = {0};

// 数组指针指向 malloc 系统调用动态分配的堆内存
int  *parr = (int*)malloc(sizeof(int) * N);
free(parr);  // 释放
```

值得注意的是, 在数组中**插入**或**删除**元素时, 为了保证其他元素仍以紧凑且连续的方式存储在内存中, 需要移动对所操作元素的后续所有元素, 因此这些操作的时间复杂度为$O(n)$.

array标准库
详见[标准库文档](https://docs.python.org/zh-cn/3/library/array.html)

# 字符串

**字符串（String）**是由任意数量的字符所构成的有限序列. 在现代高级编程语言中, 字符串一般被当做存储文本的数据结构, 可记为:

\begin{equation}
string=c_0c_1c_2...c_{n-1}
\end{equation}

在C语言中并不存在原生的字符串类型, 因此采用以'\0'为结束标记的字符型数组作为替代. 这种实现方式的优点在于能够通过下标索引直接原地修改字符串的内容, 但缺点在于无法将字符串所包含的内容作为哈希表的键, 只能使用字符串的首地址作为替代. 值得注意的是, `char`类型只占用1个字节, 因此只能表示ASCII字符; 而`wchar`类型的字符占用2个字节, 因此可以存储Unicode编码的字符.

而在Python中, 内置的字符串类型`str`被定义为存储**不可变序列**的数据结构, 这意味着字符串将被当作常量处理, 任何修改字符串的方法都会生成新的字符串常量:

```python
>>> s = "a"
>>> id0 = id(s)
>>> s+="b"
# 字符串是常量 因此会生成新的字符串 "ab"
>>> s
'ab'
>>> id1 = id(s)
>>> id0==id1  # s指向了新生成的字符串对象
False
>>> s[1]="c"  # 常量不支持直接修改
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

尽管基于**引用计数（Reference Counting）**的垃圾回收机制可以保证拼接过程中丢弃的字符串常量不会造成内存泄漏, 但生成与销毁字符串的成本却不容小觑. 例如, 在拼接$10^7$次的前提下, 使用`join()`方法要比直接使用`+`快20%左右.

```python
def func_timer(func):
    def insider(*args):
        st = time.perf_counter()
        func(*args)
        print(time.perf_counter() - st)
    return insider

@func_timer
def str_add(base, adder, times):
    for i in range(times):
        base += adder

@func_timer
def join_add(base, adder, times):
    base.join(adder for i in range(times))

A, N = "nginx" * 16, 10**7

# 0.7467752849988756
str_add("", A, N)
# 0.6037130299991986
join_add("", A, N)
```

但要注意的是, 由于CPython解释器具有**常数折叠（Constant Folding）**机制, 少量的静态字符串拼接操作会在转换为字节码时自动优化为单个字符串常量, 因此在实际使用中可能感受不到[各种拼接方式](https://www.jiqizhixin.com/articles/2018-11-01-3)之间的性能差异.

在编程语言中，字符串往往由特定字符集内有限的字符组合而成，根据其特点，对字符串的 操作 可以归结为以下几类：

字符串的比较、连接操作（不同编程语言实现方式有所不同）；

涉及子串的操作，比如前缀，后缀等；

字符串间的匹配操作，如 KMP 算法、BM 算法等。

## 双指针

对撞指针: 反转字符串, 分割数组, 求和ii, 验证回文串isalnum()
快慢指针:

# 链表

内存模型

与数组的区别 适用场景区别

数组: 地址连续 支持随机访问 扩展性差 插入删除成本高

链表: 地址分散 不支持随机访问 访问需要遍历 不支持二分法 扩展性强 插入删除成本低

与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费 O(N) 时间，其中 N 是链表的长度。

例如，在上面的示例中，头结点是 23。访问第 3 个结点的唯一方法是使用头结点中的“next”字段到达第 2 个结点（结点 6）; 然后使用结点 6 的“next”字段，我们能够访问第 3 个结点。

你可能想知道为什么链表很有用，尽管它在通过索引访问数据时（与数组相比）具有如此糟糕的性能。 在接下来的两篇文章中，我们将介绍插入和删除操作，你将了解到链表的好处。

## 单向链表

判断环

## 双向链表

LRU cache

# 二分查找

必须有序

关键属性

二分查找的最基础和最基本的形式。
查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。
不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。

区分语法

初始条件：left = 0, right = length-1
终止：left > right
向左查找：right = mid-1
向右查找：left = mid+1

```python
def binarySearch(nums, target):
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```

抽象二分查找
[寻找重复数](https://leetcode-cn.com/explore/learn/card/binary-search/215/more-practices-ii/858/)

[三种模板](https://leetcode-cn.com/explore/learn/card/binary-search/212/template-analysis/847/)

`bisect`模块

## 多维数组

二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组, 所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。
这个定义可以推广多

## 高性能向量计算

注意: 为了防止概念混淆, 本文给出以下定义.

标量：很简单，就是一个数，1，2，5，108等等
向量：[1,2]，[1,2,3]，[1,2,3,4]，[3,5,67,·······,n]都是向量
矩阵：[[1,3],[3,5]]，[[1,2,3],[2,3,4],[3,4,5]]，[[4,5,6,7,8],[3,4,7,8,9],[2,11,34,56,18]]是矩阵
张量：[[[1,2],[3,4]],[[1,2],[3,4]]]

# 位图

# 案例1: 动态数组的内存分配

# 案例2: 子序列与子串问题

# 案例3: 位运算与位图

# 参考内容
