---

layout:     post
title:      深入理解数据结构（四）
subtitle:   栈和队列
date:       2020-02-04 10:00:00
author:     "Remilia Scarlet"
header-img: "2020/06/06/t6XpBn.jpg"
catalog: true
mathjax: true
tags:
    - 数据结构
---

# 栈

不一定是线性结构, 只要满足先入后出即可
一般情况下我们都使用线性结构来实现栈
只要你不在乎造作的复杂度, 当然也可以用二叉树来实现栈

list.append(x) 向链表尾部添加一个元素, 等价于: a[len(a):]=[x]
list.extend(iterable) 向链表尾部添加iterable中的所有元素, 等价于: a[len(a):]=iterable
list.pop() 默认弹出最后一个元素

判断括号匹配

## 实现最小栈

栈中元素记录的是与当前最小值的残差

data = num - min

当$data < 0$时, 说明新入栈的元素为最小元素, 因此需要更新$min=num$

在取回真实值时, 如果$data>=0$则直接返回$data+min$, 如果$data<0$则说明要弹出的值为最小值, 因此需要更新$min=min-data$

例如, 实现一个能[在常数时间内检索到最小元素的栈](https://leetcode-cn.com/problems/min-stack/):

```python
class MinStack:

    def __init__(self):
        self._min = None
        self._entry = []


    def push(self, x: int) -> None:
        if self._min is None: self._min = x

        # 栈中存储的是元素与当前最小值的差
        res = x - self._min

        # 更新最小值
        if res < 0: self._min = x

        self._entry.append(res)


    def pop(self) -> None:
        res = self._entry.pop()

        # 更新最小值
        if res < 0: self._min -= res

        # 如果栈为空则清除最小值
        if not self._entry: self._min = None


    def top(self) -> int:
        # 如果最后一个元素小于零 则说明应该返回当前最小值
        return max(self._min, self._entry[-1] + self._min)


    def getMin(self) -> int:
        return self._min  # 时间复杂度为O(1)
```

## 深度优先搜索

DFS

## 内存中的栈

函数调用原理

# 队列

## 实现循环队列

dqueue是专门优化的队列, 支持循环

双指针循环队列

<https://leetcode-cn.com/explore/learn/card/queue-stack/216/queue-first-in-first-out-data-structure/864/>

## 广度优先搜索

BFS

## 消息队列

生产者消费者模型

# 案例1: 用栈实现队列

# 案例2: 用队列实现栈

# 案例3

# 参考内容
